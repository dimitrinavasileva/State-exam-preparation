UPR 1

#lang racket
; коментар на един ред
#| коментар
на няколко
реда |#

; примитивни изрази
;100 ; -> 100
;"This is a string." ; -> "This is a string."
;+ ; -> #<procedure:+>

; префиксен запис на операции
;(+ 10 25) ; -> 35
;(- 10 25) ; -> -15
;(* 2 3) ; -> 6
; префиксният запис позволява прилагане на някои операции над повече от 2 аргумента
;(+ 1 2 3) ; -> 6
;(+ 1 2 3 4 5 6 7 8 9 10) ; -> 55

;(/ 10 3) ; -> 3 1/3
;(+ 1.5 2 3) ; -> 6.5
;(sqrt 16) ; -> 4
;(sqrt -16) ; -> 0+4i

; вложени изрази
;(+ (* 2 3) (- 5 4) (+ 1 2 3)) ; -> 13
;(+ (* 2 3 (+ 1 2 (- 4 3)))) ; -> 24 (2*3*4)

; булевите стойности в Racket са #t и #f, съответно за истина и лъжа
;(< 3 4) ; -> #t
;(> 3 4) ; -> #f

; равенстовто е само едно равно, а не ==-то от  С++
;(= 3 4) ; -> #f
; отрицание - с not
;(not (= 3 4)) ; -> #t

; логически оператори
;(and #t #f) ; -> #f
;(or #t #f)  ; -> #t
;(not #t)    ; -> #f

; тук булевите стойности са специален, нечислов тип. Не може да ги третираме като числа.
;(= #t 1) ; -> =: contract violation  expected: number?  given: #t

; дефиниране на променлива - задаваме име и стойност
(define x 5)
;x ; -> 5
;(+ x 2) ; -> 7
;(+ x x) ; -> 10

; ползваме термина "променлива", но дефакто това са константи - x не може да промени стойността си след като вече е дефинирано
;(define x 6) ; -> module: identifier already defined in: x

; дефиниране на функция - (define (<име> <аргумент 1> <аргумент 2> ... <аргумент n>) (<тяло>))
(define (f x) (+ x 1))
; израз трябва да бъде обграден в скоби за да бъде оценен. При липсата на скоби просто получаваме информация за името на процедурата
;f ; -> #<procedure:f>
;(f 1) ; -> 2
(define (g x y z) (+ x y z))


; Упражнение 1:
; Задача 1. Да се напише функция (square x), която връща квадрата на дадено число x.
(define (square x)(* x x))

;(square 5)    ; -> 25
;(square 2.25) ; -> 5.0625

; Задача 2. Да се дефинира фунцкия (myMin a b), която приема два аргумента и връща по-малкия от тях.
(define (myMin a b)
  (if (< a b)
      a
      b))
; if-а в Racket се оформа с обикновени кръгли скоби - (if (<условие>) <then-израз> <else-израз>). Няма нужда от ключова дума else - просто вторият израз е else-частта.
; тук изразите са просто по една стойност, но ако бяха по-сложни щяхме да ги обградим всеки в скоби

;(myMin 12.02 12.0001) ; -> 12.0001
;(myMin 4 2)           ; -> 2

; Задача 3. Да се дефинира функция (myMinSquare a b), коята приема два аргумента и връща квадрата на по-малкия от двата аргумента.
(define (myMinSquare a b)(square (myMin a b)))

;(myMinSquare 17 15)    ; -> 225
;(myMinSquare 12.3 6.5) ; -> 42.25

; Задача 4. Да се дефинира функция (sumCubes a b), която приема два аргумента a и b и връща сумата на техните кубове.
(define (cube x)(* x x x))
;(cube 5) ; -> 125

(define (sumCubes a b)
  (+ (cube a) (cube b)))

;(sumCubes 2 3) ; -> 35 (8 + 27)

; Задача 5. Да се дефинира функция (inside? x a b), която приема три аргумента - реално число x и границите a и b на реален интервал.
; Функцията да проверява дали числото принадлежи на интервала.

; прието е в Racket предикати (функции, които връщат булеви стойности) да се изписват с ? в края на името им
(define (inside? x a b)
  (and (<= a x) (<= x b)))

;(inside? 5.25 2 6)    ; -> #t
;(inside? 4 1.25 3.29) ; -> #f

; Задача 6. Да се дефинира функция (squaresAverage a b), която връща средно аритметичното от сумата на квадратите на a и b.
(define (squaresAverage a b)
  (/ (+ (square a) (square b)) 2))

;(squaresAverage 4 5) ; -> 20 1/2

; Задача 7. Да се дефинира функция (fact n), която пресмята n!.

; Математическата дефиниция на факториел:
;           { 1             , n = 0
; fact(n) = { 
;           { n * fact(n-1) , иначе

; Как бихме го написали в процедурен стил (примерно на С++):
; int fact(n) {
;     int result = 1;
;     for (int i = 1; i <= n; ++i)
;         result *= i;
;
;     return result;
; }

(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))
; директно преведохме математическата дефиниция - без цикли, без променлива в която да пазим резултата.

;(fact 1) ; -> 1
;(fact 2) ; -> 2
;(fact 3) ; -> 6
;(fact 5) ; -> 120
;(fact 10) ; -> 3628800
;(fact 40) ; -> 815915283247897734345611269596115894272000000000



; локални функции
(define (global-function x)
  (define (local-function y) (+ x y)) ; локалната функция "вижда" аргументите на глобалната, и може да ги ползва в своето тяло
  (local-function 5))

;(global-function 4)
;(local-function 5) ; -> local-function: unbound identifier - local-function е "видима" само за global-function, и следователно не може да се ползва извън тялото на global-function

; Задача 8. Да се дефинира функция (myGCD a b), която намира най-големия общ делител на числата a и b.
(define (myGCD a b)
  (define (helper a b) ; дефиниране на локална функция
    (if (= b 0)
        a
        (helper b (remainder a b))))
  (if (< a b)
      (helper b a)
      (helper a b)))

;(myGCD 15 5) ; -> 5
;(myGCD 5 15) ; -> 5
;(myGCD 13 6) ; -> 1
;(myGCD 6 13) ; -> 1

; Често при по-сложни задачи се налага да дефинираме локална функция, понякога повече от една.
; Когато не можем да измислим смислено име за локалната функция (или просто не ни се занимава), обикновено я кръщаваме просто "helper".

; Задача 9. Да се дефинира функция (myFib n), която получава един аргумент n и връща n-тото число от редицата на Фибоначи.
; Забележка: Редицата е 1, 1, 2, 3, .. и е индексирана от 0.
(define (myFib n)
  (if (or (= n 0) (= n 1))
      1
      (+ (myFib (- n 1)) (myFib (- n 2)))))

;(myFib 0) ; -> 1
;(myFib 1) ; -> 1
;(myFib 2) ; -> 2
;(myFib 3) ; -> 3
;(myFib 4) ; -> 5

; Горното решение е рекурсивно - поражда се верига от обръщения към функцията с "по-прости" аргументи (тук аргументите стават по-малки, но в други задачи промяната може да е различна), докато не се достигне базов случай.
; да проследим развитието на процеса:
;    (myFib 3)
; => (+ (myFib 2) (myFib 1))
; => (+ (+ (myFib 1) (myFib 0)) 1)
; => (+ (+ 1 1) 1)
; => (+ 2 1)
; -> 3
; имаме фаза на "разгъване" и фаза на "сгъване"

; Задача 10. Да се напише итеративно решение на Задача 7 (вижте Лекция 2 за детайлно описание на "итеративен процес").
(define (myFibIter n)
  (define (helper counter prev acc)
    (if (= counter n)
        acc
        (helper (+ counter 1) acc (+ acc prev))))
  (helper 0 0 1))

; prev е съкратено за previous - този аргумент съдържа предишното число на Фибоначи
; acc е съкратено за accumulated - наричаме този аргумент така, тъй като в него "акумулираме" резултата.
; Бихме могли да го кръстим и по-друг начин - current (или curr за по-кратко), тъй като съдържа текущото число на Фибоначи, или пък result (или res).

;(myFibIter 0) ; -> 1
;(myFibIter 1) ; -> 1
;(myFibIter 2) ; -> 2
;(myFibIter 3) ; -> 3
;(myFibIter 4) ; -> 5

; В итеративното решение, на всяка стъпка състоянието на изчисленията се описва от "променливи на състоянието" (state variables) и правило, с което може да се премине към следващата стъпка.
; Тук всъшност итеративната част е в helper, а не в главната функция - тя само извиква helper с подходящи аргументи

; да проследим развитието на процеса:
;    (myFibIter 4)
;            counter prev acc
; => (helper 0       0    1)
; => (helper 1       1    1)
; => (helper 2       1    2)
; => (helper 3       2    3)
; => (helper 4       3    5)
; -> 5

; Забележете, че в "итеративния" процес пак има рекурсия - дефиницията на итеративен във Функционалното програмиране не споменава липса на рекурсия.
; В тази парадигма нямаме средствата на императивните езици, така че почти всичко става с рекурсия.

; Защо са ни итеративните решения? Основната причина е ефективност.
; Може да проверим с time - вградена функция, която засича времето за изпълнение.

; примерни резултати от изпълнението
;(time (myFib 40))         ; -> cpu time: 12344 real time: 12737 gc time: 62
;(time (myFibIter 40))     ; -> cpu time: 0 real time: 1 gc time: 0
;(time (myFibIter 40000))  ; -> cpu time: 188 real time: 194 gc time: 125
;(time (myFibIter 400000)) ; -> cpu time: 8000 real time: 8243 gc time: 5531
; Може да се види колко по-бързо е итеративното решение. В случая на Фибоначи, директното рекурсивно решение е изключително бавно, тъй като на всяка стъпка правим по две рекурсивни извиквания.
; В други функции, като например факториел (при която има само едно рекурсивно извикване), рекурсивното решение няма да е толкова бавно, но пак ще е по-бавно от съответното итеративно.

UPR 2

#lang racket
; Коментари - в качените решения има разни поясняващи коментари. Поглеждайте си ги вкъщи, в случай че аз забравя да ги спомена на място.
; По този повод - неща които забравих миналия път:
; - вложени изрази - внимаваме със скобите и префиксния запис
;(+ (* 2 3) (- 5 4) (+ 1 2 3)) ; -> 13
;(+ (* 2 3 (+ 1 2 (- 4 3)))) ; -> 24 (2*3*4)

; - защо "inside?" беше кръстена така? Просто в Racket е прието предикати (функции, които връщат булеви стойности) да се изписват с ? в края на името им.

; - защо в последните задачи кръстихме локалните функции "helper"? Когато не можем да измислим смислено име за локалната функция (или просто не ни се занимава),
; обикновено ползваме това име - тези функции са точно "помощници" на главните функции.


; да преговорим някои неща от миналия път

; префиксен запис на операции
;(10 + 25) ; application: not a procedure;
;(+ 10 25) ; -> 35

; дефиниране на функция - (define (<име> <аргумент 1> <аргумент 2> ... <аргумент n>) (<тяло>))
(define (f x) (+ x 1))
; израз трябва да бъде обграден в скоби за да бъде оценен. При липсата на скоби просто получаваме информация за името на процедурата
;f ; -> #<procedure:f>
;+ ; -> #<procedure:+>
;(f 1) ; -> 2

; локални функции
(define (global-function x)
  (define (local-function y) (+ x y)) ; локалната функция "вижда" аргументите на глобалната, и може да ги ползва в своето тяло
  (local-function 5))

;(global-function 4)
;(local-function 5) ; -> local-function: unbound identifier - local-function е "видима" само за global-function, и следователно не може да се ползва извън тялото на global-function


; Фибоначи

; Рекурсивно решение - поражда се верига от обръщения към функцията с "по-прости" аргументи (тук аргументите стават по-малки, но в други задачи промяната може да е различна), докато не се достигне базов случай.
(define (myFib n)
  (if (or (= n 0) (= n 1))
      1
      (+ (myFib (- n 1)) (myFib (- n 2)))))

; да проследим развитието на процеса:
;    (myFib 3)
; => (+ (myFib 2) (myFib 1))
; => (+ (+ (myFib 1) (myFib 0)) 1)
; => (+ (+ 1 1) 1)
; => (+ 2 1)
; -> 3
; Имаме фаза на "разгъване" (увеличаване на броя операции - тук събиране) и фаза на "сгъване" (намаляване на броя операции).
; Интерпретаторът трябва да запазва формираната верига от операции, за да може по-късно да ги изпълни.

; Иитеративно решение - на всяка стъпка състоянието на изчисленията се описва от "променливи на състоянието" (state variables) и правило, с което може да се премине към следващата стъпка.
; Тук всъшност итеративната част е в helper, а не в главната функция - тя само извиква helper с подходящи аргументи
(define (myFibIter n)
  (define (helper counter prev acc)
    (if (= counter n)
        acc
        (helper (+ counter 1) acc (+ acc prev))))
  (helper 0 0 1))

; Текущите стойности на променливите counter, prev и acc дават пълна информация за текущото състояние.

; prev е съкратено за previous - този аргумент съдържа предишното число на Фибоначи
; acc е съкратено за accumulated - наричаме този аргумент така, тъй като в него "акумулираме" резултата.
; Бихме могли да го кръстим и по-друг начин - current (или curr за по-кратко), тъй като съдържа текущото число на Фибоначи, или пък result (или res).

; да проследим развитието на процеса:
;    (myFibIter 4)
;            counter prev acc
; => (helper 0       0    1)
; => (helper 1       1    1)
; => (helper 2       1    2)
; => (helper 3       2    3)
; => (helper 4       3    5)
; -> 5

; Забележете, че в "итеративния" процес пак има рекурсия - дефиницията на итеративен във Функционалното програмиране не споменава липса на рекурсия.
; В тази парадигма нямаме средствата на императивните езици, така че почти всичко става с рекурсия.

; Защо са ни итеративните решения? Основната причина е ефективност.
; Може да проверим с time - вградена функция, която засича времето за изпълнение.

; примерни резултати от изпълнението
;(time (myFib 40))         ; -> cpu time: 12344 real time: 12737 gc time: 62
;(time (myFibIter 40))     ; -> cpu time: 0 real time: 1 gc time: 0
;(time (myFibIter 40000))  ; -> cpu time: 188 real time: 194 gc time: 125
;(time (myFibIter 400000)) ; -> cpu time: 8000 real time: 8243 gc time: 5531
; Може да се види колко по-бързо е итеративното решение. В случая на Фибоначи, директното рекурсивно решение е изключително бавно, тъй като на всяка стъпка правим по две рекурсивни извиквания.
; В други функции, като например факториел (при която има само едно рекурсивно извикване), рекурсивното решение няма да е толкова бавно, но пак ще е по-бавно от съответното итеративно.



; Упражнение 2:
; Условен оператор cond - позволява повече от 2 случая (за разлика от if-a). Може да го считаме като аналог на if с поредица от else if-ове в С++, или на switch.
(define (conditions x)
  (cond [(< x 0) "negative"]
        [(= x 0) "zero"]
        [(and (> x 1) (< x 1000)) "positive"]
        [else "very big"]))
; Изразите между квадратните скоби се наричат "клаузи". Те се оценяват отгоре-надолу, като ако условния израз в някоя от тях се оцени до истина, се "влиза" в клаузата и се връща стойността на израза вдясно.

; else клаузата винаги се оценява до истина, следователно в нея винаги се влиза. Затова я слагаме накрая, и с нея обработваме последния случай.
; Не е задължителна, но е хубаво да я имаме, за да не изпуснем без да искаме някой случай.

; Ако изпуснем случай, и изпълним функцията с аргумент който попада точно в него, няма да се получи грешка, а функцията просто ще върне #<void> - специална константа за липсата на резултат.
; Това най-вероятно не е нещото което искаме, така че трябва да покриваме всички случаи.

;(conditions -3)   ; -> "negative"
;(conditions 0)    ; -> "zero"
;(conditions 3)    ; -> "positive"
;(conditions 3000) ; -> "very big"

; Може и да подравним изразите - не е задължително, но ги прави по-четими, особено когато тестовете се различават много по дължина - тук третият тест е много по-дълъг от другите.
(define (conditions-aligned x)
  (cond [(< x 0)                  "negative"]
        [(= x 0)                  "zero"]
        [(and (> x 1) (< x 1000)) "positive"]
        [else                     "very big"]))


; Задача 1. Да се дефинира функция (minDivisor n), която намира най-малкия делител на числото n > 1.
(define (minDivisor n)
  (define (helper current)
    (if (= (remainder n current) 0)
        current
        (helper (+ current 1))))
  (helper 2))

;(minDivisor 25) ; -> 5

; Задача 2. Да се дефинира функция (maxDivisor n), която намира най-големия делител на числото n > 1.
; a) решение с помощна функция с два аргумента
(define (maxDivisor n)
  (define (helper current max)
    (cond [(>= current n)              max]
          [(= (remainder n current) 0) (helper (+ current 1) current)]
          [else                        (helper (+ current 1) max)]))
  (helper 2 1))

; това е много често срещана форма на cond - в първия случай проверяваме дали сме завършили (обикновено дали единият аргумент е надвишил някаква стойност) и връщаме резултат,
; във втория проверяваме дали е изпълнено условие и правим рекурсивно извикване,
; а третият ни случай е else, и там обикновено имаме подобно рекурсивно извикване, но с други аргументи, тъй като тук условието от втория случай не е било изпълнено

; b) решение с помощна функция с един аргумент
(define (maxDivisor2 n)
  (define (helper current)
    (if (= (remainder n current) 0)
        current
        (helper (- current 1))))
  (helper (- n 1)))

; c) решение чрез Задача 1.
(define (maxDivisor3 n) (/ n (minDivisor n)))

;(maxDivisor 145)  ; -> 29
;(maxDivisor2 145) ; -> 29
;(maxDivisor3 145) ; -> 29

; Задача 3. Да се дефинира функция (sumOfOdds a b), която намира сумата на нечетните числа в затворения интервал [a, b].
; a) за всяко число от интервала проверяваме дали е нечетно
(define (sumOfOdds a b)
  (define (helper start end acc)
    (cond [(> start end) acc]
          [(odd? start)  (helper (+ start 1) end (+ acc start))]
          [else          (helper (+ start 1) end acc)]))
  (helper a b 0))

; b) като а), но не пазим текущата сума
(define (sumOfOdds2 a b)
  (cond [(> a b)  0]
        [(odd? a) (+ a (sumOfOdds3 (+ a 1) b))]
        [else     (sumOfOdds3 (+ a 1) b)]))

; c) по-ефективно - правим проверка за четност само за началото на интервала, след което просто просто прескачаме четните числа, като обхождаме интервала със стъпка 2 вместо 1
(define (sumOfOdds3 a b)
  (define (helper start end acc)
    (if (> start end)
        acc
        (helper (+ start 2) end (+ acc start))))
  (if (odd? a)
      (helper a b 0)
      (helper (+ a 1) b 0)))

;(sumOfOdds 2 10)  ; -> 24 (3 + 5 + 7 + 9)
;(sumOfOdds 3 14)  ; -> 48

; Задача 4. Да се дефинира функция (leap-year? year), която проверява дали годината year е високосна.
(define (divides? m n) (= 0 (remainder n m)))
(define (leap-year? year)
  (cond [(not (divides? 4 year))   #f]
        [(not (divides? 100 year)) #t]
        [(not (divides? 400 year)) #f]
        [else                      #t]))

; Задача 5. Да се дефинира функция (valid-date? day month year), която проверява дали така зададената дата е валидна.
(define (valid-date? day month year)
  #| (define (valid-year? year)
    (and (<= 1900 year) (<= year 9999))) |#
  ; ние предаваме аргумента year от главната функция към локалната без промяна. Това е излишно - локалната функция "вижда" аргументите на главната, и може да ги достъпи директно
  (define valid-year?
    (and (<= 1900 year) (<= year 9999)))
  ; така предикатът всъщност няма собствени аргументи - той е просто стойност, която се определя от аргументите на главната функция
  (define valid-month?
    (and (<= 1 month) (<= month 12)))

  (define days-in-month
    (cond [(or (= month 1) (= month 3) (= month 5) (= month 7) (= month 8) (= month 10) (= month 12)) 31]
          [(or (= month 4) (= month 6) (= month 9) (= month 11))                                      30]
          [(leap-year? year)                                                                          29]   ; ако не сме влезли в някой от първите 2 случая, значи сме във февруари (или месецът въобще не е валиден, 
          [else                                                                                       28])) ; но това ще се провери от valid-month?. Все пак, ако искаме, може тук да добавим проверка за (= month 2))
  (define valid-day?
    (and (<= 1 day) (<= day days-in-month)))

  (and valid-day? valid-month? valid-year?))
  
;(valid-date? 5 5 1998)   ; -> #t
;(valid-date? 29 2 1998)  ; -> #f
;(valid-date? 29 2 1904)  ; -> #t
;(valid-date? 29 2 1905)  ; -> #f
;(valid-date? 31 1 1900)  ; -> #t
;(valid-date? 31 4 1990)  ; -> #f
;(valid-date? 31 13 1900) ; -> #f
;(valid-date? 32 1 1900)  ; -> #f

UPR 3

#lang racket
; Упражнение 3:

; Задача 1. Да се дефинира функция (prime? n), която проверява дали дадено число n е просто.
; a) проверяваме дали някое от числата от 2 до n дели n. Ако да - значи n не е просто.
(define (prime? n)
  (define (helper current)
    (if (> current (/ n 2)) ; най-големият делител на n винаги е <= n/2, така че няма нужда да проверяваме за числата между n/2 и n - те със сигурност не са делители
        #t
        (and (not (= (remainder n current) 0)) (helper (+ current 1)))))
  ;(helper 2))
  ; ако директно извикаме helper, ще получим че 1 е просто, което е грешно. Това става защото helper на първата стъпка ще провери (> 2 (/ 1 2)), което е вярно, и директно ще върне #t
  ; може да избегнем този проблем, като просто в главната функция правим проверка преди да извикаме helper
  (if (<= n 1)
      #f
      (helper 2)))

;(prime? 1) ; -> #f
;(prime? 2) ; -> #t
;(prime? 3) ; -> #t
;(prime? 6)  ; -> #f
;(prime? 11) ; -> #t
;(prime? 61) ; -> #t

; за проверката за делене има вградена функция
(require math/number-theory) ; за divides?
; с require може да включваме библиотеки, подобно на #include в C++

; b) тук тръгваме наобратно - от n/2 надолу, докато стигнем до 2
(define (prime-alt? n)
  (define (helper current)
    (cond [(< current 2)        #t]
          [(divides? current n) #f]
          [else                 (helper (- current 1))]))
  (if (<= n 1)
      #f
      (helper (quotient n 2))))

; Задача 2. Да се дефинира функция (palindrome? n), която проверява дали дадено число n е палиндром.
(define (palindrome? n)
  (define (reverseNumber rest acc)
    (if (= rest 0)
      acc
      (reverseNumber (quotient rest 10) (+ (remainder rest 10) (* acc 10)))))
  (= n (reverseNumber n 0)))

; да проследим изпълнението на reverseNumber:
;    (reverseNumber 123 0) => 123 равно ли е на 0? Не, минаваме към else частта.
; => (reverseNumber 12 (+ 3 (* 0 10)))
; => (reverseNumber 12 3)  => 12 равно ли е на 0?  Не, минаваме към else частта.
; => (reverseNumber 1 (+ 2 (* 3 10)))
; => (reverseNumber 1 32)  => 1 равно ли е на 0?   Не, минаваме към else частта.
; => (reverseNumber 0 (+ 1 (* 32 10)))
; => (reverseNumber 0 321) => 0 равно ли е на 0?   Да, връщаме acc
; -> 321

;(palindrome? 181) ; -> #t
;(palindrome? 5)   ; -> #t
;(palindrome? 18)  ; -> #f

; Задача 3. Да се дефинира функция (countPalindromes a b), която пресмята броя на палиндромите в даден интервал [a, b].
; a) линейно рекурсивно
(define (countPalindromes a b)
  (cond [(> a b)         0]
        [(palindrome? a) (+ 1 (countPalindromes (+ a 1) b))]
        [else            (countPalindromes (+ a 1) b)]))

; b) линейно итеративно
(define (countPalindromesIter a b)
  (define (helper curr end count) ; имаме ли нужда от end?
    (cond [(> curr end)       count]
          [(palindrome? curr) (helper (+ curr 1) end (+ count 1))]
          [else               (helper (+ curr 1) end count)]))
  (helper a b 0))
; Тук end не се променя в никой от случаите, т.е. на всяка стъпка има една и съща стойност - стойността на b.
; Аргументите на главната функция са видими от локалната, така че може вместо end просто да проверяваме директно за b.

; c) като b), но без аргумента end
(define (countPalindromesIter2 a b)
  (define (helper curr count) 
    (cond [(> curr b)         count]
          [(palindrome? curr) (helper (+ curr 1) (+ count 1))]
          [else               (helper (+ curr 1) count)]))
  (helper a 0))

;(countPalindromes 10 20)     ; -> 1
;(countPalindromes 1 10)      ; -> 9
;(countPalindromesIter 10 20) ; -> 1
;(countPalindromesIter 1 10)  ; -> 9

; Задача 4. Да се дефинира функция (sumPalindromes a b), която пресмята сумата на палиндромите в даден интервал [a, b].

; може много лесно да адаптираме решенията на миналата задача
(define (sumPalindromes a b)
  (cond [(> a b)         0]
        [(palindrome? a) (+ a (sumPalindromes (+ a 1) b))] ; само тук има промяна - добавяме самото число вместо единица
        [else            (sumPalindromes (+ a 1) b)]))

;(sumPalindromes 100 150) ; -> 605 (101 + 111 + ... + 141)

(define (sumPalindromesIter a b)
  (define (helper curr sum) ; променили сме count на sum
    (cond [(> curr b)         sum]
          [(palindrome? curr) (helper (+ curr 1) (+ sum curr))] ; както горе - добавяме текущото число вместо единица
          [else               (helper (+ curr 1) sum)]))
  (helper a 0))

;(sumPalindromesIter 100 150) ; -> 605

; Задача 5. Да се дефинира функция (countDivisors n), която пресмята броя на естествените делители на дадено число n.
; Фунцкията да генерира итеративен изчислителен процес.

; отново може лесно да адаптираме решението на countPalindromes, по-точно това от c) подточка
(define (countDivisors n)
  (define (helper curr count)
    (cond [(> curr n)               count]
          [(divides? curr n) (helper (+ curr 1) (+ count 1))] ; променяме единствено проверката
          [else                     (helper (+ curr 1) count)]))
  (helper 1 0)) ; Всяко естествено число се дели на 1 и на себе си

;(countDivisors 1)  ; -> 1 (само 1)
;(countDivisors 2)  ; -> 2 (1, 2)
;(countDivisors 18) ; -> 6 (1, 2, 3, 6, 9, 18)
;(countDivisors 13) ; -> 2 (1, 13)

; Задача 6. Да се дефинира функция (increasingDigits? n), която проверява дали цифрите на числото n са подредени в (строго) нарастващ ред.
; а) като пазим последната цифра
(define (increasingDigits? n)
  (define (helper curr lastDigit)
    (cond [(= curr 0)                        #t] ; за едноцифрено число условието със сигурност е изпълнено
          [(< (remainder curr 10) lastDigit) (helper (quotient curr 10) (remainder curr 10))] ; проверяваме дали предпоследната цифра е < от последната
          [else                              #f]))
  (helper (quotient n 10) (remainder n 10))) ; взимаме числото без последната си цифра, както и самата цифра
; Тук проверяваме за строго неравенство, което означава че при числа с повтарящи се цифри като например 1233 ще считаме че НЕ изпълняват предиката.
; Бихме могли да си ползваме <=, зависи какво точно се има предвид под "нарастващ ред" - тук в условието е специфицирано строго.

;(increasingDigits? 5)    ; -> #t
;(increasingDigits? 15)   ; -> #t
;(increasingDigits? 1234) ; -> #t
;(increasingDigits? 1233) ; -> #f
;(increasingDigits? 1534) ; -> #f
;(increasingDigits? 2134) ; -> #f

; да проследим процеса за 1234:
;    (increasingDigits? 1234)
; => (helper 123 4) => 123 по-малко ли е от 10? Не, минаваме към втория случай - 3 по-малко ли е от 4? Да - влизаме във втората клауза.
; => (helper 12 3)  => 12 по-малко ли е от 10?  Не, минаваме към втория случай - 2 по-малко ли е от 3? Да - влизами във втората клауза.
; => (helper 1 2)   => 1 по-малко ли е от 10? Да, влизаме в първата клауза.
; -> #t

; а за 1534
;    (increasingDigits? 1534)
; => (helper 153 4) => 153 по-малко ли е от 10? Не, минаваме към втория случай - 3 по-малко ли е от 4? Да - влизаме във втората клауза.
; => (helper 15 3)  => 15 по-малко ли е от 10?  Не, минаваме към втория случай - 5 по-малко ли е от 3? Не - минаваме към третия случай.
; => но третият случай е else, в такава клауза винаги се влиза, следователно връщаме стойността на израза от дясно.
; -> #f

; b) вместо cond бихме могли да ползваме or и and
(define (increasingDigits2? n)
  (define (helper curr lastDigit)
    (or (= curr 0)
        (and (< (remainder curr 10) lastDigit)
             (helper (quotient curr 10) (remainder curr 10)))))
  (helper (quotient n 10) (remainder n 10)))

; c) може и без помощна функция - няма да пазим последната цифра, а просто на всяка стъпка ще намираме последната и предпоследната цифра на текущото число.
(define (increasingDigits3? n)
  (or (= n 0)
      (and (< (remainder (quotient n 10) 10) (remainder n 10))
           (increasingDigits3? (quotient n 10)))))

; Задача 7. Да се дефинира функция (calcSum x n), която по зададени x и n изчислява сумата: 1 + x + x^2 + x^3 + ... + x^n.
; a) неефективно - на стъпка i смятаме x^i от нулата
(define (calcSum x n)
  (define (helper counter sum)
    (if (> counter n)
        sum
        (helper (+ counter 1) (+ sum (expt x counter)))))
  (helper 1 1))

;(calcSum 2 0) ; -> 1
;(calcSum 2 1) ; -> 3
;(calcSum 2 2) ; -> 7
;(calcSum 2 3) ; -> 15

; b) може да се възползваме от това, че ако запазим миналото събираемо (x^(i-1)), то текущото може да получим като просто умножим миналото веднъж по x
(define (calcSumOptimal x n)
  (define (helper counter current sum)
    (if (> counter n)
        sum
        (helper (+ counter 1) (* current x) (+ sum current))))
  (helper 1 x 1))

;(calcSumOptimal 2 0) ; -> 1
;(calcSumOptimal 2 1) ; -> 3
;(calcSumOptimal 2 2) ; -> 7
;(calcSumOptimal 2 3) ; -> 15

;(time (calcSum        2 10000))  ; -> cpu time: 79 real time: 77 gc time: 63
;(time (calcSumOptimal 2 10000))  ; -> cpu time: 15 real time: 12 gc time: 15
;(time (calcSum        2 100000)) ; -> cpu time: 1844 real time: 1857 gc time: 783
;(time (calcSumOptimal 2 100000)) ; -> cpu time: 765 real time: 779 gc time: 392

UPR 4

#lang racket
; Упражнение 4:
; Функции от по-висок ред, Ламбда функции

; Функции от по-висок ред - функции, които манипулират други функции (получават функция като аргумент или връщат функция като резултат)
; Пример. Функция, която по подадени числа a и b и едноаргументна функция f, намира f(a) + f(a+1) + ... + f(b)
(define (sum a b f)
  (if (> a b)
      0
      (+ (f a) (sum (+ a 1) b f))))

(define (increment x) (+ x 1))
(define (square x) (* x x))

;(sum 1 3 increment) ; -> 9  (2 + 3 + 4)
;(sum 1 3 square)    ; -> 14 (1 + 4 + 9)

; За да тестваме функцията sum дефинирахме нови функции, които да подадем като аргументи. Но това са много кратки и елементарни функции, които най-вероятно ще ползваме само тук.
; Обособяването им като отделни функции с имена може да е излишно, и за да го избегнем ще ползваме така наречените "анонимни" (безименни) функции. Дефинират се чрез ключовата дума lambda:
;(lambda (x) (+ x 1)) ; -> #<procedure:...ения/ex4.rkt:21:0>
; Тук не сме подали аргумент, и съответно изразът се оценява до процедура, а не конкретна стойност
; Тъй като функцията е анонимна, ние всъщност няма как да я извикаме след дефинирането ѝ.

; може да ползваме и гръцката буква λ - в DrRacket е 'Ctrl' + '\'
;(λ (x) (+ x 1))

; Извикването с аргументи става така - ((lambda (arg1 arg2 ... argN) <тяло>) value1 value2 ... valueN)
;((λ (x) (+ x 1)) 2)           ; -> 3 (2 + 1)
;((λ (x y z) (+ x y z)) 1 2 3) ; -> 6

; На практика ламбдите не се ползват като в горните примери - обикновено се подават като аргументи на други функции, или се връщат като резултат.
;(sum 1 3 (λ (x) (+ x 1))) ; -> 9  (2 + 3 + 4)
;(sum 1 3 (λ (x) (+ x 5))) ; -> 21 (6 + 7 + 8)

;(sum 1 3 (λ (x) (* x x))) ; -> 14 (1 + 4 + 9)

;(sum 1 3 (λ (x) (* x 2))) ; -> 12 (2 + 4 + 6)
;(sum 1 3 (λ (x) (* x 3))) ; -> 18 (3 + 6 + 9)

; Това бяха примери за приемане на ламбда като аргумент - да видим и един за връшане.
; Ще дефинираме едноаргументна функция, която връща друга едноаргументна функция, добавяща своя аргумент към този на първата (леко извъртяно, но е само за пример).
(define (addY x) (λ (y) (+ x y)))

;(addY 5) ; -> #<procedure:...ения/ex4.rkt:42:17>
; addY не връша конкретна стойност, а функция - това е функция, която ще добавя 5 към аргумента си

;((addY 5) 4) ; -> 9 (5 + 4)
; чак когато подадем аргумент на върнатата функция може да получим резултат

; може да именуваме върната функция
(define addFive (addY 5)) ; тук в дефиницията не слагаме аргумент, тъй като вече го има от дефиницията на addY
; (define addFive (addY 5)) е еквивалентно на (define addFive (λ (y) (+ 5 y)), което пък е еквивалентно на (define (addFive y) (+ 5 y))
;(addFive 4) ; -> 9

; Трябва да внимаваме с аргументите
(define (add x y) (λ (a b) (+ a b))) ; Какво връща тази функция?
;((add 3 4) 13 14) ; -> 27 (13 + 14)
; Тук 3 и 4 ги игнорираме тотално - те се подават като аргументи, но в тялото не се ползват те, а a и b, които се подават на ламбдата.

; Задача 1. Да се дефинират следните функции:
; а) (myNegate predicate?) - отрицание на предикат 
(define (myNegate predicate?)
  (λ (x) (not (predicate? x))))

;((λ (x) (> x 10)) 5)             ; -> #f
;((myNegate (λ (x) (> x 10))) 5) ; -> #t

; Може да именуваме горния предикат
(define greaterThanTen? (λ (x) (> x 10)))

;(greaterThanTen? 5)            ; -> #f
;((myNegate greaterThanTen?) 5) ; -> #t

; b) (twice f) - прилага функцията f два пъти
(define (twice f)
  (λ (x) (f (f x))))

;(twice (λ (x) (+ x 1)))     ; -> #<procedure:...ения/ex4.rkt:77:2>
;((twice (λ (x) (+ x 1))) 3) ; -> 5 ((3 + 1) + 1)

; c) (myCompose f g) - композиция
(define (addOne x) (+ x 1))
(define (multByTwo x) (* x 2))

(define (myCompose f g)
  (λ (x) (f (g x))))

;(myCompose addOne multByTwo)     ; -> #<procedure:...ения/ex4.rkt:80:2>
;((myCompose addOne multByTwo) 3) ; -> 7 ((3 * 2) + 1 = 6 + 1 - композираните функции се изпълняват от дясно на ляво) 
;((myCompose multByTwo addOne) 3) ; -> 8 ((3 + 1) * 2 = 4 * 2)

;(myCompose (λ (x) (+ x 5)) (λ (x) (* x 4)))     ; -> #<procedure:...ения/ex4.rkt:80:2>
;((myCompose (λ (x) (+ x 5)) (λ (x) (* x 4))) 3) ; -> 17 (3 * 4) + 5 = 12 + 5
;((myCompose (λ (x) (* x 4)) (λ (x) (+ x 5))) 3) ; -> 32 (3 + 5) * 4 = 8 * 4

; може и миналата функция да дефинираме чрез тази
(define (twiceWithCompose f) (myCompose f f))
;((twiceWithCompose addOne) 3) ; -> 5

; d) (myRepeat f n) - прилагане на f n пъти (n-кратна композиция)
; рекурсивно:
(define (myRepeat f n)
  (if (<= n 0)
      identity ; вградена функция идентитет - връша това, което ѝ е подадено, без никакви промени
      (myCompose f (myRepeat f (- n 1)))))

;(myRepeat addOne 3)     ; -> #<procedure:...ения/ex4.rkt:87:2>
;((myRepeat addOne 3) 1) ; -> 4 (((1 + 1) + 1) + 1)

; итеративно: на k-та стъпка аргументът acc представлява k-кратната композиция на f
(define (myRepeatIter f n)
  (define (helper counter acc)
    (if (> counter n)
        acc
        (helper (+ counter 1) (compose f acc)))) ; тук вместо нашето myCompose ползваме вградената функция за композиция
  (helper 1 identity))

;(myRepeatIter addOne 3) ; -> #<procedure:composed>
; (тъй като ползвахме вградената функция за композиция, така че резултатът е малко по-различен - в горните примерни това което е заместено от многоточие
; е пътят до файла на моя компютър, но при вградената функция получаваме директно името)
;((myRepeatIter addOne 3) 1)  ; -> 4


; Задача 2. Да се дефинира функция от по-висок ред (deriveN f n eps), която намира n-та производна (по-точно - приближение на производна) на едноаргументната реална функция f с точност eps.

; първо да сметнем първа производна (по-точно - приближение на първа производна)
(define (derivative f eps)
  (λ (x) (/ (- (f (+ x eps))
               (f x))
            eps)))
; когато имаме по-дълги и сложни изрази, понякога разделяме аргументите на отделни редове - автоформатирането на DrRacket би трябвало да ги подравни
; без новите редове щеше да изглежда така: (/ (- (f (+ x eps)) (f x)) eps)))

; примерна функция
(define (f x) (* 2 x x x))

;(f 2) ; -> 16 (2 * 2^3 = 2 * 8)

; 1e-3 е scientific notation за 1 * 10^(-3) = 0.001
;((derivative f 1e-3) 2) ; -> 24.0120019999992
;((derivative f 1e-6) 2) ; -> 24.000012004421478
; f(x) = 2*(x^3) => f'(x) = 6*(x^2) => f'(2) = 6*4 = 24, но ние търсим приближение, а не точната стойност
; при различни eps ще получаваме различни резултати, но не е задължително при намаляване на eps винаги да получаваме по-голяма точност - зависи от спецификите на функцията.
; При прекалено малко eps даже получаваме 0, което е напълно грешно.

(define (deriveN f n eps)
  (if (<= n 0)
      f
      (deriveN (derivative f eps) (- n 1) eps)))

; f'(x) = 6*(x^2) => f''(x) = 12*x => f''(2) = 24
;((deriveN f 2 1e-6) 2) ; -> 23.998580900297384
; f''(x) = 12*x   => f'''(x) = 12  => f'''(2) = 12
;((deriveN f 3 1e-3) 2) ; -> 12.000015203739167


; Частично прилагане (currying) на функции - прилагане на функция към само част от аргументите ѝ. Резултатът е нова функция с по-малък брой аргументи - все едно сме фиксирали първите няколко.
(define (myCurry f x)
  (λ (y) (f x y)))

(define twoToThePowerOf (myCurry expt 2)) ; в израза (expt x y) все едно фиксираме x да е 2, т.е. получаваме (expt 2 y), или 2^y
;(twoToThePowerOf 4) ; -> 16
;(twoToThePowerOf 8) ; -> 256

; нашата реализация работи само за функции на 2 аргумента, но вградената в езика функция curry работи за произволен брой аргументи
(define (f1 x y z) (+ x y z))

(define f2 (curry f1 5))
;(f2 3 4) ; -> (f1 5 3 4) -> 12
;(f2 1 2) ; -> (f1 5 1 2) -> 8

(define f3 (curry f1 5 3))
;(f3 4)   ; -> (f1 5 3 4) -> 12

(define f4 (curry f1 5 3 4))
;f4 ; f4 вече не е процедура, а просто стойността на (f1 5 3 4) -> 12

;(define f5 (curry f1 5 3 4 6))
; -> arity mismatch - f1 има само 3 аргумента

; На Haskell частичното прилагане като цяло е по-удобно. Там ще видим повече и по-полезни примери, и ще го ползваме на практика.



; Пример за letrec/let*
; Задача 3. Да се дефинира функция (orderedBy pred? x), която проверява дали цифрите на числото x са подредени според предиката pred?.
; (като обобщение на increasingDigits? от миналия път - според предиката може да проверяваме за нарастващ или намаляващ ред (и потенциално някакви други, нестандартни подредби))
(define (orderedBy pred? x) ; pred? е двуместен предикат
  (letrec ; с обикновения let ще даде грешка при secondToLast - butLast: unbound identifier in: butLast
      ([butLast      (quotient x 10)]         ; всички цифри на числото без последната
       [last         (remainder x 10)]        ; последна цифра
       [secondToLast (remainder butLast 10)]) ; hover върху butLast ще покаже откъде се взима оценката
    (cond [(< x 10)                  #t]
          [(pred? secondToLast last) (orderedBy pred? butLast)]
          [else                      #f])))

;(orderedBy < 1234) ; -> #t
;(orderedBy < 4321) ; -> #f
;(orderedBy > 4321) ; -> #t
;(orderedBy > 1231) ; -> #f
;(orderedBy < 1231) ; -> #f
;(orderedBy (λ (x y) (= x (+ y 2))) 86420) ; -> #t

; Задача 4. Да се дефинира функция (perfectNumber? n), която проверява дали числото n e съвършено, т.е. дали е равно на сбора на делителите си.
(define (perfectNumber? n)
  (define (sumDivisors current sum)
    (cond [(= current n)               sum]
          [(= (remainder n current) 0) (sumDivisors (+ current 1) (+ sum current))]
          [else                        (sumDivisors (+ current 1) sum)]))
  (= (sumDivisors 1 0) n))

;(perfectNumber? 1)  ; -> #f ; 1 ≠ 0
;(perfectNumber? 14) ; -> #f ; 1 + 2 + 7 ≠ 14
;(perfectNumber? 6)  ; -> #t ; 1 + 2 + 3 = 6
;(perfectNumber? 28) ; -> #t ; 1 + 2 + 4 + 7 + 14 = 28

; Задача 5. Да се дефинира функция (newton-sqrt x), която пресмята корен квадратен по метода на Нютон с итеративно подобряване на приближението:
; https://en.wikipedia.org/wiki/Newton%27s_method#Square_root

; а) със смятане до n-та стъпка
(define (newtonSqrt x n)
  (define (f y) (- (* y y) x))
  (define (helper i xi)
    (if (> i n)
        xi
        (helper (+ i 1) (- xi (/ (f xi)
                                 ((derivative f 1e-6) xi))))))
  (helper 0 x))

;(newtonSqrt 36 0) -> 18.500000176874487
;(newtonSqrt 36 1) -> 10.22297328269325
;(newtonSqrt 36 6) -> 6.0
;(newtonSqrt 36 7) -> 6.0

; b) с проверка на грешката
(define (newtonSqrtAlt x)
  (define (helper x guess)
    ;(define error (abs (- (* guess guess) x)))
    ;(define next (average guess (/ x guess)))
    (let ([error (abs (- (* guess guess) x))] ; локалните дефиниции на error и next могат да се внесат в let
          [next (/ (+ guess (/ x guess)) 2)])
      (if (< error 0.001) ; с намаляване на второто число ще се получава по-точен резултат
          guess
          (helper x next))))
  (helper x 1.0))

; c) с проверка на грешката и показване на броя итерации
(define (newtonSqrtFinal x)
  (define (helper x guess iterations)
    (let ([error (abs (- (* guess guess) x))]
          [next (/ (+ guess (/ x guess)) 2)])
      (if (< error 0.001)
          (cons guess iterations) ; cons конструира нещо наречено "точкова двойка" - ще говорим в детайли следващия път когато започнем списъци, засега може да мислите за наредена двойка (guess, iterations)
          (helper x next (+ iterations 1)))))
  (helper x 1.0 0))

;(newtonSqrtAlt 5)       ; -> 2.2360688956433634
;(newtonSqrtFinal 5)     ; -> '(2.2360688956433634 . 4)
;(newtonSqrtFinal 36)    ; -> '(6.000000005333189 . 6)
;(newtonSqrtFinal 10000) ; -> '(100.00000025490743 . 10)

UPR 5

#lang racket
; Точкови двойки
; конструират се чрез cons (конструктор)
;(cons 1 2) ; -> '(1 . 2)
;(cons 5 "string") ; -> '(5 . "string")
; може да достъпваме елементите чрез car и cdr (селектори)
(define a (cons 1 2))
;(car a) ; -> 1
;(cdr a) ; -> 2

; Дроби (рационални числа)
(define (make-rat a b) (cons a b)) ; a/b -> (a . b)
(define (numer x) (car x)) ; numerator
(define (denom x) (cdr x)) ; denominator

(define (+rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (denom x) (numer y)))
            (* (denom x) (denom y))))
(define (-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (denom x) (numer y)))
            (* (denom x) (denom y))))
(define (*rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (/rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (=rat x y)
  (= (* (numer x) (denom y))
     (* (denom x) (numer y))))

(define (normalize-rat x)
  (let* ([a (numer x)]
         [b (denom x)]
         [c (gcd a b)])
    (make-rat (/ a c)
              (/ b c))))
(define (+rat-normalized x y)
  (normalize-rat (make-rat (+ (* (numer x) (denom y))
                              (* (denom x) (numer y)))
                           (* (denom x) (denom y)))))

;(+rat (make-rat 1 8) (make-rat 3 8)) ; -> '(32 . 64)
;(+rat-normalized (make-rat 1 8) (make-rat 3 8)) ; -> '(1 . 2)

; Комплексни числа
(define (make-complex a b) (cons a b))
(define (real-part x) (car x))
(define (imag-part x) (cdr x))

(define (+complex x y)
  (make-complex (+ (real-part x) (real-part y))
                (+ (imag-part x) (imag-part y))))
(define (-complex x y)
  (make-complex (- (real-part x) (real-part y))
                (- (imag-part x) (imag-part y))))
(define (*complex x y)
  (make-complex (- (* (real-part x) (real-part y)) (* (imag-part x) (imag-part y)))
                (+ (* (real-part x) (imag-part y)) (* (imag-part x) (real-part y)))))

;(+complex (make-complex 1 5) (make-complex 3 (- 2))) ; -> '(4 . 3)


; Списъци
; Синтаксис - `(1 2 3 4) - в началото има символа "`"
; Може да конструираме списъци и чрез функцията list
;`(1 2 3 4)     ; -> '(1 2 3 4)
;(list 1 2 3 4) ; -> '(1 2 3 4)

; Списъците всъщност се реализират чрез точкови двойки, и съответно се конструират чрез cons.
; Списъкът представлява точкова двойка, съдържаща като първа координата някакъв елемент, а като втора - друг списък. Този списък също е точкова двойка, и т.н.
; На всеки елемент от списъка съответства по една точкова двойка, на някакво ниво на вложение. Последният елемент е представен от точкова двойка, чиято втора координата е празен списък.
; `(1 2 3) == (cons 1 (cons 2 (cons 3 `())))

; Тъй като Racket е динамичен език, списъците могат да бъдат хетерогенни
;`(1 2 3 "string" 4 5.2) ; -> '(1 2 3 "string" 4 5.2)

; Може да имаме и списъци от списъци
;`((1 2 3) (4) (5 6)) ; -> '((1 2 3) (4) (5 6))
; Забележете, че списъците вътре нямат ` пред отварящата скоба


; Задача 0. В Racket има много вградени функции за работа със списъци. Ще демонстрираме някои от тях, като за тези d) нататък ще покажем и примерни реализации.
; a) дали нещо е празен списък
;(null? `())      ; -> #t
;(null? `(1 2 3)) ; -> #f

; b) дали нещо е списък
;(list? `())      ; -> #t
;(list? `(1 2 3)) ; -> #t
;(list? 1)        ; -> #f

; c) глава и опашка на списък
;(car `(1 2))   ; -> 1
;(cdr `(1 2))   ; -> '(2)
;(cdr `(1 2 3)) ; -> '(2 3)
;(car `())      ; car: contract violation

; (cadr xs) е еквивалентно на (car (cdr xs)) - глава на опашката на списъка, което е всъщност втория елемент
;(cadr `(1 2 3 4 5))   ; -> 2
;(caddr `(1 2 3 4 5))  ; -> 3
;(cadddr `(1 2 3 4 5)) ; -> 4
;caddddr обаче няма - само до 4ти елемент може с вградените

;(car `((1 2 3) (4) (5 6)))   ; -> '(1 2 3)
;(cdr `((1 2 3) (4) (5 6)))   ; -> '((4) (5 6))
;(caar `((1 2 3) (4) (5 6)))  ; -> 1
;(caadr `((1 2 3) (4) (5 6))) ; -> 4

; има и first и rest, които са еквивалентни на car и cdr, но работят само за списъци (car/cdr работят и за точкови двойки)
;(first `(1 2 3)) ; -> 1
;(rest `(1 2 3))  ; -> '(2 3)

;(car (cons 1 2))   ; -> 1
;(first (cons 1 2)) ; first: contract violation

; d) дължина на списък
(define (length xs)
  (if (null? xs)
      0
      (+ 1 (length (cdr xs)))))

; Това е една от основните схеми за работа със списъци - разглеждаме два случая:
; - за празен списък, при което приключваме с изпълнението и връщаме някакъв резултат;
; - за непразен списък, при което извършваме някакво действие с главата на списъка (тук може би не се вижда много добре, тъй като никъде не взимаме (car xs),
; но действието което извършваме е преброяване, чрез добавянето на единица) и рекурсивно извикваме функцията върху опашката на списъка.

;(length `())      ; -> 0
;(length `(1 2 3)) ; -> 3

; xs като име на аргумент списък е по-скоро от Haskell, но ще го ползваме и тук. Ако ви е по-удобно, може като име да ползвате lst (за предпочитане не list, тъй като това е име на вградена функция).
; Идеята е, че тъй като в математиката ползваме x като име на произволна променлива, а списъка съдържа няколко елемента,
; то за име на произволен списък взимаме "множествено число" на x, което е xs (все едно много x-ове). Ако имаме втори списък той е ys, третия - zs.

; e) принадлежност към списък
(define (myMember x xs)
  (cond [(null? xs)     #f]
        [(= x (car xs)) #t]
        [else           (myMember x (cdr xs))]))

;(myMember 1 `(1 2 3)) ; -> #t
;(myMember 2 `(1 2 3)) ; -> #t
;(myMember 4 `(1 2 3)) ; -> #f
; Вградената функция member работи по малко по-различен начин - когато елемента принадлежи, не връща просто #t, а списъка от този елемент нататъка
;(member 2 `(1 2 3)) ; -> '(2 3)
; Тъй като Racket е динамичен език, може една функция в различни случаи да връща различни типове.

; Освен това, в Racket, повечето булеви операции приемат всяка стойност различна от #f за #t, така че няма проблем да ползваме резултата на member като булева стойност.
;(if (member 2 `(1 2 3)) "yes" "no") ; -> "yes"
; тук (member 2 `(1 2 3)) се оценява до '(2 3), което се интерпретира като #t

;(myMember `(1 2) `((1 2) (3 4))) ; =: contract violation expected: number?  given: '(1 2)
; = работи само за числа. За да сравняваме по-сложни типове, като списъци, трябва да ползваме предиката equal?
(define (myMemberWithEqual x xs)
  (cond [(null? xs)     #f]
        [(equal? x (car xs)) #t]
        [else           (myMemberWithEqual x (cdr xs))]))

;(myMemberWithEqual `(1 2) `((1 2) (3 4))) ; -> #t
;(myMemberWithEqual `(1 3) `((1 2) (3 4))) ; -> #f
; вграденият member ползва equal?, така че с него може да търсим в списъци от списъци

; f) конкатенация на два списъка
(define (myAppend xs ys)
  (if (null? xs)
      ys
      (cons (car xs) (myAppend (cdr xs) ys))))

;(myAppend `(1 2 3) `(4 5)) ; -> '(1 2 3 4 5)
; Вградения append може да работи и за повече аргументи, подобно на аритметичните операции
;(append `(1 2 3) `(4 5) `(6 7) `(8 9 10)) ; -> '(1 2 3 4 5 6 7 8 9 10)
;(append `(1 2 3) `(4 5 (6 7 (8 9)))) ; -> '(1 2 3 4 5 (6 7 (8 9)))

; g) обръщане на списък
(define (reverse xs)
  (define (helper xs result)
    (if (null? xs)
        result
        (helper (cdr xs) (cons (car xs) result))))
  (helper xs `()))

;(reverse `(1 2 3))     ; -> '(3 2 1)
;(reverse `(1 2 (3 4))) ; -> '((3 4) 2 1)
  
; Задача 1. Да се дефинира функция (minimum xs), която намира най-малкия елемент на списъка xs.
(define (minimum xs)
  (define (helper xs min)
    (cond [(null? xs)       min]
          [(< (car xs) min) (helper (cdr xs) (car xs))]
          [else             (helper (cdr xs) min)]))
  (helper (cdr xs) (car xs))) ; може да се изпълнява само върху непразни списъци (празен списък няма car и cdr части)
                              ; Но дали трябва да обработим този случай? Списък без елементи има ли минимален елемент?
  #|(if (null? xs)
      (error "Empty list")
      (helper (cdr xs) (car xs))))|#

;(minimum `(2 3 1 4 5))   ; -> 1
;(minimum `(2 3 4 5 1 0)) ; -> 0

; Задача 2. Да се дефинира функция (countMaximum xs), която намира броя на срещанията на най-големия елемент на списъка xs.
; първо намираме максимума, после броим елементите равни на него
(define (maximum xs)
  (define (helper xs max)
    (cond [(null? xs)       max]
          [(> (car xs) max) (helper (cdr xs) (car xs))]
          [else             (helper (cdr xs) max)]))
  (helper (cdr xs) (car xs)))

(define (countMaximum xs)
  (define (helper xs max cnt)
    (cond [(null? xs)       cnt]
          [(= max (car xs)) (helper (cdr xs) max (+ cnt 1))]
          [else             (helper (cdr xs) max cnt)]))
  (helper xs (maximum xs) 0))

;(countMaximum `(1 2 3))   ; -> 1
;(countMaximum `(1 3 2))   ; -> 1
;(countMaximum `(1 3 3 2)) ; -> 2
;(countMaximum `(1 3 2 3 2 2 3 3 3 2)) ; -> 5

; но така се налага да обходим списъка два пъти - веднъж за максимума, втори път за броенето
; може да го направим само с едно обхождане
(define (countMaximumAlt xs)
  (define (helper xs max cnt)
    (cond [(null? xs)       cnt]
          [(< max (car xs)) (helper (cdr xs) (car xs) 1)]
          [(= max (car xs)) (helper (cdr xs) max      (+ cnt 1))]
          [else             (helper (cdr xs) max      cnt)]))
  (helper (cdr xs) (car xs) 1))

; Задача 3. Да се дефинира функция (ordered? xs pred), която проверява дали списък е сортиран възходящо/низходящо според подадена функция за сравнение
(define (ordered? xs pred?)
  (cond [(null? xs)                 #t] ; празният списък винаги е сортиран
        [(null? (cdr xs))           #t] ; списък с един елемент (т.е. списък с празна опашка) винаги е сортиран
        [(pred? (car xs) (cadr xs)) (ordered? (cdr xs) pred?)] ; cadr == (car (cdr), т.е. втория елемент
        [else                       #f]))

;(ordered? `(1 2 3 4) <)  ; -> #t
;(ordered? `(1 1 1 1) <)  ; -> #f
;(ordered? `(1 1 1 1) <=) ; -> #t
;(ordered? `(1 2 3 0) <)  ; -> #f
;(ordered? `(1 0 2 3) <)  ; -> #f
;(ordered? `(1 0 2 3) >)  ; -> #f
;(ordered? `(4 3 2 1) >)  ; -> #t

; може да напишем функцията orderedBy от миналия път, ползвайки тази
; първо трябва да конвертираме число до списък
(define (numToListReverse n)
    (if (= n 0)
        `()
        (cons (remainder n 10) (numToListReverse (quotient n 10)))))

(define (numToList n)
    (reverse (numToListReverse n)))

;(numToList 123) ; -> '(1 2 3)

(define (orderedNumber? n pred?)
    (ordered? (numToList n) pred?))

;(orderedNumber? 123 <) ; -> #t
;(orderedNumber? 132 <) ; -> #f

; може да направим и число от списък
(define (listToNum xs)
  (define (helper xs result)
    (if (null? xs)
        result
        (helper (cdr xs) (+ (car xs) (* result 10)))))
  (helper xs 0))

;(listToNum `(1 2 3 4 5)) ; -> 12345

UPR 6

#lang racket
; Упражнение 6:
; Теория:
; Още функции за работа със списъци:
; 1) (take xs n) - взима първите n елемента на списък
(define (take xs n)
  (cond [(null? xs) `()]
        [(<= n 0)   `()]
        [else       (cons (car xs) (take (cdr xs) (- n 1)))]))

;(take `(1 2 3 4 5) 0) ; -> '()
;(take `(1 2 3 4 5) 3) ; -> '(1 2 3)
;(take `(1 2 3 4 5) 7) ; -> '(1 2 3 4 5)
; вграденият take работи по подобен начин, но не може да вземе повече елемента от колкото има в списъка. В последния пример ще даде contract violation  expected: a list with at least 7 elements  given: '(1 2 3 4 5)


; 2) (drop xs n) - премахва първите n елемента на списък
(define (drop xs n)
  (cond [(null? xs) `()]
        [(<= n 0)   xs]
        [else       (drop (cdr xs) (- n 1))]))

;(drop `(1 2 3 4 5) 0) ; -> '(1 2 3 4 5)
;(drop `(1 2 3 4 5) 3) ; -> '(4 5)
;(drop `(1 2 3 4 5) 7) ; -> '()
; отново вграденият drop не може да drop-не повече елемента от колкото има в списъка, и в последния пример ще даде drop: contract violation  expected: a list with at least 7 elements  given: '(1 2 3 4 5)

; 3) (zip xs ys) - връща списък от двойки (Ai,Bi), където Ai е i-тия елемент на xs, Bi е i-тия елемент на ys
; ако списъците са с различна дължина, резултата е с дължината на по-късия от аргументите
(define (zip xs ys)
  (cond [(null? xs) `()]
        [(null? ys) `()]
        [else (cons (cons (car xs) (car ys)) (zip (cdr xs) (cdr ys)))]))

; (zip `(1 2 3 4) `(a b c)) ; -> '((1 . a) (2 . b) (3 . c))

; take и drop са вградени в езика,
; но zip не е (вградена е в Haskell, където има отделен тип за n-торка, в частност 2-орка, т.е. двойка)

; Функции от по-висок ред за работа със списъци:

; 1) (any? pred? xs) - проверява дали поне един елемент на списъка удовлетворява даден предикат
(define (any? pred? xs)
  (if (null? xs)
      #f
      (or (pred? (car xs)) (any? pred? (cdr xs)))))

;(any? odd? `(1 2 3 4 5 6)) ; -> #t
;(any? odd? `(2 4 6))       ; -> #f

; 2) (all? pred? x) - проверява дали всеки елемент на списъка удовлетворява даден предикат
(define (all? pred? xs)
  (if (null? xs)
      #t
      (and (pred? (car xs)) (all? pred? (cdr xs)))))

;(all? odd? `(1 2 3 4 5 6)) ; -> #f
;(all? odd? `(1 3 5))       ; -> #t

; В Racket има вградени функции ormap и andmap, които също извършват подобно действие, но имат и някои допълнителни детайли.
; В Haskell си има any и all (без въпросителните накрая, тъй като там липсва тази конвенция за предикати)

;(ormap odd? `(1 2 3 4 5 6))  ; -> #t
;(ormap odd? `(2 4 6))        ; -> #f
;(andmap odd? `(1 2 3 4 5 6)) ; -> #f
;(andmap odd? `(1 3 5))       ; -> #t

; 3) (map f xs) - прилага f към всеки елемент на xs
; Например ако xs -> `(a b c), то (map f xs) -> `((f a) (f b) (f c))
(define (myMap f xs)
  (if (null? xs)
      `()
      (cons (f (car xs)) (myMap f (cdr xs)))))

;(map sqr `(1 2 3 4 5))             ; -> '(1 4 9 16 25)
;(map (λ (x) (+ x 1)) `(1 2 3 4 5)) ; -> '(2 3 4 5 6)

; вграденият map може да работи и с повече аргументи (стига функцията, която му е подадена също да може)
;(map cons `(1 2 3) `(4 5 6)) ; -> '((1 . 4) (2 . 5) (3 . 6)) (същото като zip)
;(map list `(1 2 3) `(4 5 6) `(7 8 9) `(10 11 12)) ; -> '((1 4 7 10) (2 5 8 11) (3 6 9 12))

; 4) (filter p xs) - премахва (филтрира) елементите, за които предикатът p е грешен
(define (filter p xs)
  (cond [(null? xs)   `()]
        [(p (car xs)) (cons (car xs) (filter p (cdr xs)))]
        [else         (filter p (cdr xs))]))

;(filter odd? `(1 2 3 4 5))            ; -> '(1 3 5)
;(filter (λ (x) (> x 2)) `(1 2 3 4 5)) ; -> '(3 4 5)

; 5) (apply f xs) - връша оценката на f със аргументи - елементите на списъка
; т.е. (apply f `(a b c)) -> (f a b c)

;(apply + `(1 2 3 4)) ; -> (+ 1 2 3 4) -> 10
;(apply * `(1 2 3 4)) ; -> (* 1 2 3 4) -> 24
;(apply * `(0 1 2 3)) ; -> (* 0 1 2 3) -> 0
;(apply append `((1 2 3) () (4 5 6) (7) (8 9))) ; -> '(1 2 3 4 5 6 7 8 9)

; използвайки map и append, може да направим друга дефиниция на filter
(define (filter2 p xs)
  (apply append (map (λ (x) (if (p x) (list x) `())) xs)))
; map с тази ламбда функция ще замени всеки елемент със списък - празен за тези, за които предиката не е верен
;                                                              - с 1 елемент за тези, за които предиката е верен
; apply append ще конкатенира всички тези списъци - празните ще изчезнат и ще останат само елементите, за които предиката е верен
;(filter2 odd? `(1 2 3 4 5)) ; -> '(1 3 5)

; 6) foldl, foldr - обхождане на списък с последователно прилагане на f
; foldr обхожда отдясно наляво, а foldl отляво надясно
(define (foldr f init xs) ; init е начална/нулева стойност. Например при fold-ване с + най-вероятно ще е 0, а при * ще бъде 1
  (if (null? xs)
      init
      (f (car xs) (foldr f init (cdr xs)))))

;(foldr + 0 `(1 2 3 4)) ; -> 10
;(foldr * 0 `(1 2 3 4)) ; -> 0
;(foldr * 1 `(1 2 3 4)) ; -> 24
;(foldr max 0 `(1 2 3 2 5 4 3)) ; -> 5

(define (foldl f init xs)
  (if (null? xs)
      init
      (foldl f (f init (car xs)) (cdr xs))))

;(foldr - 0 `(1 2 3 4)) ; -> -2
;(foldl - 0 `(1 2 3 4)) ; -> -10
; Защо резултатите са различни?
; (foldr - 0 `(1 2 3 4))
; -> 1 - (2 - (3 - (4 - 0))) ; bracketing to the RIGHT
; -> 1 - (2 - (3 - 4))
; -> 1 - (2 - (-1))
; -> 1 - 3
; -> -2

; (foldl - 0 `(1 2 3 4)) 
; -> (((0 - 1) - 2) - 3) - 4 ; bracketing to the LEFT
; -> ((-1 - 2) - 3) - 4
; -> (-3 - 3) - 4
; -> -6 - 4
; -> -10

; при асоциативна и комутативна операция (като +) не би трябвало да има разлика, тъй като скобите и аргументите може да се подредят по произволен начин 
;(foldr + 0 `(1 2 3 4)) ; -> 10
;(foldl + 0 `(1 2 3 4)) ; -> 10

; вграденият foldl всъщност работи по различен начин (https://stackoverflow.com/questions/42144068/how-do-foldl-and-foldr-work-broken-down-in-an-example)
;(foldl - 0 `(1 2 3 4))
; ако закоментираме нашия foldl, за да се извика вградения, ще получим 2, тъй като
; (4 - (3 - (2 - (1 - 0)))) -> 2
; нашите реализации са подобни на тези в Haskell, но в Racket е взето друго решение за левия фолд (https://stackoverflow.com/questions/8778492/why-is-foldl-defined-in-a-strange-way-in-racket)

; може да ползваме fold при дефиниране на някои минали функции
(define (appendWithFold xs ys)
  (foldr cons ys xs))

;(appendWithFold `(1 2 3) `(4 5 6)) ; -> `(1 2 3 4 5 6)


; 7) (zipWith f xs ys) - връща списък с елементи функцията f приложена към елемент на xs и елемент на ys
; т.е. списък от (f Ai Bi), където Ai е i-тия елемент на xs, Bi е i-тия елемент на ys
; отново ако списъците са с различна дължина, резултата е с дължината на по-късия от аргументите
(define (zipWith f xs ys)
  (cond [(null? xs) `()]
        [(null? ys) `()]
        [else (cons (f (car xs) (car ys)) (zipWith f (cdr xs) (cdr ys)))]))

; (zipWith + `(1 2 3) `(4 5 6))         ; -> '((+ 1 4) (+ 2 5) (+ 3 6)) -> '(5 7 9)
; (zipWith * `(0 1 2 3) `(2 2 2 2 2 2)) ; -> '(0 2 4 6)
; (zipWith cons `(1 2 3 4) `(a b c))    ; -> '((1 . a) (2 . b) (3 . c)), т.е същото като обикновения zip

; map, filter, apply и foldl/foldr са вградени в езика,
; any?, all? и zipWith не са (вградени са в Haskell), но за any? и all? може да се ползват ormap и andmap


; няколко примера на curry със списъци
;(all? (curry < 4) '(5 6 7 8))    ; -> #t (дали всички елементи са по-големи от 4 (дали 4 е по-малко от всички елементи))
;(all? (curry > 5) '(4 5 6 7 8))  ; -> #f (дали всички елементи са по-малки от 5)
;(any? (curry > 7) '(5 6 7 8))    ; -> #t (дали има поне един елемент който е по-малък от 7)
;(any? (curry > 4) '(5 6 7 8))  ; -> #f (дали има поне един елемент който е по-малък от 4)

; броя на елементите на списъка, които са по-малки от 5
;(length (filter (curry < 5) `(1 2 3 4 5 6 7 8 9 10))) ; -> 5

; може да комбинираме функциите от по-висок ред, например:
;(foldl + 0 (filter (curry < 20) (map sqr `(1 2 3 4 5 6 7 8)))) ; -> 174 (25 + 36 + 49 + 64 == 5^2 + 6^2 + 7^2 + 8^2)

; друг интересен пример - транспониране на матрица на един ред
(define (transpose xss) (apply map list xss))
; предстаяваме матрицата като списък от списъци с еднаква дължина
(transpose `((1 2 3)
             (4 5 6)
             (7 8 9)))
; -> '((1 4 7) (2 5 8) (3 6 9)), или като го форматираме по-добре
; '((1 4 7)
;   (2 5 8)
;   (3 6 9))
; Как се получава това? По-горе видяхме пример за вградения map, ползван с функцията list и няколко списъка.
;(map list `(1 2 3) `(4 5 6) `(7 8 9)) ; -> '((1 4 7) (2 5 8) (3 6 9))
; в transpose имаме само един списък, но той самият съдържа списъци. Чрез apply може да вземем тези списъци като аргументи на map, и да получим точно горният пример

UPR 6

#lang racket
; Упражнение 6
; Задача 1. Да се дефинира функция (insertAtPos n x xs), която добавя елемента x на зададена позиция в списъка xs.
(define (insertAtPosError n x xs)
  (if (= n 0)        ; ако n > length xs, какво ще се случи?
      (cons x xs)
      (cons (car xs) (insertAtPosError (- n 1) x (cdr xs)))))

;(insertAtPosError 3 9 `(0 1 2 3 4)) ; -> '(0 1 2 9 3 4)
;(insertAtPosError 6 9 `(0 1 2 3 4)) ; -> car: contract violation  expected: pair?  given: '()

(define (insertAtPos n x xs)
  (cond [(null? xs) (list x)]                    ; така при n > length xs ще добавим елемента накрая
        ;[(null? xs) (error "No such position")] ; а така ще върнем грешка
        [(= n 0)    (cons x xs)]
        [else       (cons (car xs) (insertAtPos (- n 1) x (cdr xs)))]))

;(insertAtPos 3 9 `(0 1 2 3 4)) ; -> '(0 1 2 9 3 4)
;(insertAtPos 5 9 `(0 1 2 3 4)) ; -> '(0 1 2 3 4 9)
;(insertAtPos 9 9 `(0 1 2 3 4)) ; -> '(0 1 2 3 4 9)

; Задача 2. Да се дефинира функция, която изтрива първото срещане на даден елемент в списък
(define (removeFirst x xs)
  (cond [(null? xs)     `()]
        [(= (car xs) x) (cdr xs)]
        [else           (cons (car xs) (removeFirst x (cdr xs)))]))

;(removeFirst 2 `(1 2 3 2 4 2)) ; -> '(1 3 2 4 2)
;(removeFirst 0 `(1 2 3))       ; -> '(1 2 3)

; Задача 3. Да се дефинира функция, която изтрива всички срещания на даден елемент на списък
(define (removeAll x xs)
  (cond [(null? xs)     `()]
        [(= (car xs) x) (removeAll x (cdr xs))] ; разликата с горната функция е само тук - вместо да спрем обработването и да върнем резултат, просто продължаваме нататък
        [else           (cons (car xs) (removeAll x (cdr xs)))]))

;(removeAll 2 `(1 2 3 2 4 2)) ; -> '(1 3 4)

; Задача 4. Функция (removeDuplicates xs), която премахва всички повторни срещания на елементи от списъка
; a)
(define (removeDuplicates xs)
  (define (helper found rest) ; във found ще натрупваме първите срещания на елементите
    (cond [(null? rest)              (reverse found)] ; първите срещания ще се натрупат наобратно, тъй като всяко следващо добавяме в началото на списъка
          [(member (car rest) found) (helper found (cdr rest))]
          [else                      (helper (cons (car rest) found) (cdr rest))]))
  (helper `() xs))

; b)
(define (removeDuplicates2 xs)
  (if (null? xs)
      `()
      (cons (car xs) (removeDuplicates2 (removeAll (car xs) (cdr xs))))))

;(removeDuplicates  `(1 2 1 1 2 2 2 3 4 3 3 3 4 4)) ; -> '(1 2 3 4)
;(removeDuplicates2 `(1 2 1 1 2 2 2 3 4 3 3 3 4 4)) ; -> '(1 2 3 4)

; Задача 5. Функция (sublistBetween start end xs), която взима подсписъка на xs между позициите start и end
(define (sublistBetween start end xs)
  (take (drop xs start) (- end start)))

;(sublistBetween 2 3 `(0 1 2 3 4 5 6 7 8))  ; -> '(2)
;(sublistBetween 2 6 `(0 1 2 3 4 5 6 7 8))  ; -> '(2 3 4 5)
;(sublistBetween 0 9 `(0 1 2 3 4 5 6 7 8)) ; -> '(0 1 2 3 4 5 6 7 8)

; Задача 6. Функция (countOcccurrences subxs xs), която връща броя срещания на subxs в xs.

; Първо ще дефинираме функция, проверяваща дали един списък е префикс на друг списък,
; т.е. дали вторият списък започва с първия
; а) с обхождане на списъците
(define (prefix? subxs xs)
  (cond [(null? subxs)                 #t] ; празният списък е префикс на всеки списък
        [(null? xs)                    #f] ; празният списък няма префикси    
        [(equal? (car subxs) (car xs)) (prefix? (cdr subxs) (cdr xs))]
        [else                          #f]))

;(prefix? `(1 2 3) `(1 2 3 4))         ; -> #t
;(prefix? `(1 2 3) `(0 1 2 3 4))       ; -> #f
;(prefix? `(1 2 3) (cdr `(0 1 2 3 4))) ; -> (prefix? `(1 2 3) `(1 2 3 4)) -> #t
;(prefix? `(1 2 3) `(1 2 3))           ; -> #t

; b) с използване на take
(define (prefixWithTake? subxs xs)
  (equal? subxs (take xs (length subxs))))

; вече самата функция за броене на срещанията
(define (countOcccurrences subxs xs)
  (define (helper curr cnt)
    (cond [(null? curr)         cnt]
          [(prefix? subxs curr) (helper (cdr curr) (+ cnt 1))]
          [else                 (helper (cdr curr) cnt)]))
  (helper xs 0))

;(countOcccurrences `(1) `(1 1 1 1 1))                    ; -> 5
;(countOcccurrences `(1 2 3) `(1 2 3 4 2 3 1 2 3 4 1 2))  ; -> 2
;(countOcccurrences `(1 2 3) `(4 5 6 7))                  ; -> 0
;(countOcccurrences `(1 2 3) `(2 3 4 5 6 7))              ; -> 0

; Задача 7. Функция (maxOrderedSublist xs), която връща най-дългия възходящо сортиран подсписък от списъка xs.

(define (orderedPrefix xs) ; ще намира сортираната част в началото на списъка (ако въобще има такава)
  (cond [(null? xs)              `()]
        [(null? (cdr xs))        xs]
        [(<= (car xs) (cadr xs)) (cons (car xs) (orderedPrefix (cdr xs)))]
        [else                    (list (car xs))]))

;(orderedPrefix `(5 6 7 8 1 2 3 4 5)) ; -> '(5 6 7 8)
;(orderedPrefix `(4 3 2 1 5))         ; -> '(4)

(define (maxOrderedSublist xs)
  (define (helper max curr)
    (define currPrefix (orderedPrefix curr)) ; това може да стане и с let
    (cond [(null? curr)                         max]
          [(< (length max) (length currPrefix)) (helper currPrefix (cdr curr))]
          [else                                 (helper max (cdr curr))]))
  (helper `() xs))

;(maxOrderedSublist '(1 2 2 2 2 1 2 3 4 5 6 1 2))   ; '(1 2 3 4 5 6)
;(maxOrderedSublist '(1 2 2 2 2 2 1 2 3 4 5 6 1 2)) ; '(1 2 2 2 2 2)
;(maxOrderedSublist `(4 3 2 1))                     ; '(4)

; Задача 8. Функция (flatten xss), която приема списък от списъци
; (които също могат да са от списъци, т.е. имаме произволно ниво на вложение)
; и връша списък само от елементи, т.е. списък без вложени списъци
; например `((1 2 3) (4 5 6) ((7 8) (9 10 (11 (12)))))) трябва да стане `(1 2 3 4 5 6 7 8 9 10 11 12)

(define (concat xss) ; конкатенира всички елементи на списък от списъци
  (foldr append `() xss))
(define (concat2 xss)
  (apply append xss))

(define (flatten xss)
  (cond [(null? xss) `()]
        [(list? xss) (concat (map flatten xss))]
        [else        (cons xss `())]))

;(flatten `((1 2 3) (4 5 6) ((7 8) (9 10 (11 (12))))))              ; -> '(1 2 3 4 5 6 7 8 9 10 11 12)
;(flatten `((1 (2 (3 (4 (5 6 (7 8 (9)))))) 10 (11 12 (13 14) 15)))) ; -> '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)


UPR 7

#lang racket
; От миналия път:
; Асоциативен списък - списък от точкови двойки (<ключ> . <асоциация>)
(define assocList1 `((a . 6) (b . 5) (c . 4) (d . 3) (f . 2)))
(define assocList2 (list (cons `a 6) (cons `b 5) (cons `c 4) (cons `d 3) (cons `f 2)))
;(equal? assocList1 assocList2) ; -> #t

; Задача 9. Функция (assoc key a-list), която търси key в асоциативния списък a-list и връша първия му елемент с ключ равен на key
(define (assoc key a-list) 
  (cond [(null? a-list)             #f]
        [(equal? key (caar a-list)) (car a-list)] ; caar xs == car (car xs)
        [else                       (assoc key (cdr a-list))]))
; в Racket има вградени функции assq, assv, assoc, които извършват това действие (различават се по смисъла на "равен", т.е. дали сравняват с eq?, eqv? или equal?)
  
; Задача 10. Функция (replace lst dict), която връща като резултат списък, получен от lst, в който елементите са заменени с асоциацията им в dict.
(define (replace lst dict)
  (cond [(null? lst)            `()]
        [(assoc (car lst) dict) (cons (cdr (assoc (car lst) dict)) (replace (cdr lst) dict))]
        [else                   (cons (car lst) (replace (cdr lst) dict))]))

(define (replaceWithMap lst dict)
  (define (replaceElem x)
    (let ([result (assoc x dict)])
      (if result       ; точкова двойка ще се оцени до #t
          (cdr result) ; вторият елемент на двойката е асоциацията
          x)))         ; при #f не е намерена асоциация, т.е. няма с какво да заместваме елемента => оставяме си го съшия
  (map replaceElem lst))

;(replace        `(a b c d e) assocList1) ; -> '(6 5 4 3 e)
;(replaceWithMap `(a b c d e) assocList1) ; -> '(6 5 4 3 e)

; Упражнение 7:
; генериране на списъци от числата в даден интервал
;(range 1 5)     ; -> '(1 2 3 4)
;(range 5)       ; -> '(0 1 2 3 4)
;(range 1 10 3)  ; -> '(1 4 7)
;(range 10 1 -3) ; -> '(10 7 4)

; Задача 0. Да се реализира функция (insertionSort xs), която реализира сортиране чрез вмъкване върху списък.
; първо трябва да се дефинира функция (insert x xs), която добавя елемент в сортиран (възходящо) списък на правилната позиция, така че резултатният списък също е сортиран
(define (insert x xs)
  (cond [(null? xs)     (list x)]
        [(< x (car xs)) (cons x xs)]
        [else           (cons (car xs) (insert x (cdr xs)))]))

;(insert 1 `(2 3 4)) ; -> '(1 2 3 4)
;(insert 3 `(1 2 4)) ; -> '(1 2 3 4)
;(insert 4 `(1 2 3)) ; -> '(1 2 3 4)

(define (insertionSort xs)
  (foldr insert `() xs))

;(insertionSort `(7 3 2 5 1 6 10 8 9 4)) ; -> '(1 2 3 4 5 6 7 8 9 10)

; в Racket има и вградена функция за сортиране - sort
;(sort `(7 3 2 5 1 6 10 8 9 4) <) ; -> '(1 2 3 4 5 6 7 8 9 10)
;(sort `(7 3 2 5 1 6 10 8 9 4) >) ; -> '(10 9 8 7 6 5 4 3 2 1)


; от файла "Задачи за подготовка за първото контролно по ФП"
; Задача 1. Да се дефинира функция (sum-numbers a b), приемаща два аргумента, която намира сумата на числата в интервала [a,b], чиито цифри са в низходящ (>=) ред.
(define (descending-digits? n)
  (define (helper curr lastDigit)
    (cond [(= curr 0)                         #t]
          [(>= (remainder curr 10) lastDigit) (helper (quotient curr 10) (remainder curr 10))]
          [else                               #f]))
  (helper (quotient n 10) (remainder n 10)))

(define (sum-numbers a b)
  (foldr + 0 (filter descending-digits? (range a (+ b 1)))))

;(sum-numbers 1 9)     ; -> 45
;(sum-numbers 199 203) ; -> 200
;(sum-numbers 219 225) ; -> 663

; Задача 2. Да се дефинира функция (num-bigger-elements lst), която за даден списък от числа lst връща като резултат списък с елементи от вида (lsti ni),
; където lsti е i-тият елемент на lst, а ni е броят на елементите на lst, които са по-големи от lsti.
(define (num-bigger-elements xs)
  (define (makePair x)
    (cons x (length (filter (λ (y) (> y x)) xs))))
  (map makePair xs))

;(num-bigger-elements '(5 6 3 4)) ; -> '((5 1) (6 0) (3 3) (4 2))
;(num-bigger-elements '(1 1 1))   ; -> '((1 0) (1 0) (1 0))

; Задача 3. Ако f и g са числови функции и n е естествено число, да се дефинира функция от повисок ред (switchsum f g n), която връща като резултат функция, чиято стойност в дадена
; точка x е равна на f(x)+g(f(x))+f(g(f(x)))+ ... (сумата включва n събираеми).
(define (switchsum f g n)
  (define (helper count prev result)
    (cond [(= count n)  result]
          [(odd? count) (helper (+ count 1) (f prev) (+ result prev))]
          [else         (helper (+ count 1) (g prev) (+ result prev))]))
  (λ (x) (helper 0 (f x) 0)))

;((switchsum (λ (x) (+ x 1)) (λ (x) (* x 2)) 1) 2) ; -> 3
;((switchsum (λ (x) (+ x 1)) (λ (x) (* x 2)) 2) 2) ; -> 9
;((switchsum (λ (x) (+ x 1)) (λ (x) (* x 2)) 3) 2) ; -> 16
;((switchsum (λ (x) (+ x 1)) (λ (x) (* x 2)) 4) 2) ; -> 30

; Задача 4. Да се дефинира функция (repeater str), която получава като аргумент символен низ и връща анонимна функция на два аргумента - count и glue (число и низ).
; Оценката на обръщението към върнатата функция е низ, който се получава чрез count-кратно повтаряне на низа str, при което между всеки две съседни повторения на str стои низът glue.
; Помощна информация. За да съедините няколко низа, може да използвате вградената функцията string-append:
;(string-append "I" "Love" "Racket") ; -> "ILoveRacket"
; Функцията string-append приема произволен брой агрументи и връща низ, който представлява тяхната конкатенация.
(define (repeater str)
  (define (helper count glue)
    (cond [(= count 0) ""]
          [(= count 1) str]
          [else        (string-append str glue (helper (- count 1) glue))]))
  (λ (count glue) (helper count glue)))

;((repeater "I love Racket") 3 " ") ; -> "I love Racket I love Racket I love Racket"
;((repeater "Quack") 5 "!")         ; -> "Quack!Quack!Quack!Quack!Quack"

; Задача 5. Да се дефинира функция (sum-sum-digit a b k), която намира сумата на естествените числа от a до b (0<a≤b), сумата от цифрите на които е кратна на k.
(require math/number-theory)

(define (sum-sum-digit a b k)
  (define (digit-sum n)
    (if (= n 0)
        0
        (+ (remainder n 10) (digit-sum (quotient n 10)))))
  (foldr + 0 (filter (λ (x) (divides? k (digit-sum x))) (range a (+ b 1)))))

;(sum-sum-digit 10 20 3)   ; -> 45
;(sum-sum-digit 101 141 6) ; -> 882

; Задача 6. Да се дефинира функция (max-ordered-sublist lst), която намира най-дългия възходящо сортиран подсписък на списъка от числа lst.
; това е maxOrderedSublist (Зад. 7) от Упражнение 6

; Задача 7. Да се дефинира функция (where list-elements list-predicates), която връща списък от всички елементи на list-elements, за които са изпълнени всички предикати в list-predicates.
(define (where list-elements list-predicates)
  (define (check-element x)
    (andmap (λ (pred?) (pred? x)) list-predicates))
  (filter check-element list-elements))

; (andmap f '(x1 x2 ...)) == (and (f x1) (f x2) ...)
;(andmap (lambda (x) (> x 5)) '(4 7 8)) ; -> #f (не всички са по-големи от 5

;(where '(3 4 5 6 7 8 9 10)     (list even? (λ (x) (> x 5)))) ; -> '(6 8 10) (списък от всички елементи на дадения, които са четни числа, по-големи от 5)
;(where '(3 4 5 7)              (list even? (λ (x) (> x 5)))) ; -> '() (в списъка няма четни числа, по-големи от 5)
;(where '(3 4 5 7 8 9 12 14 15) (list even? (λ (x) (> x 5)))) ; -> '(8 12 14)

; Задача 8. Да се дефинира функция (set-union xs ys), която връща обединението на множествата от числа xs и ys, представени като списъци, наредени във възходящ ред.
; Елементите на резултантното множество също трябва да са наредени във възходящ ред.
(define (set-union xs ys)
  (sort (remove-duplicates (append xs ys)) <))
; така ще правим допълнително триене на повторения и сортиране, но пък става на един ред

; дългото решение, при което избягваме повторения и директно получаваме сортирания списък
(define (set-union-alt xs ys)
  (define (helper xs ys result)
    (cond [(null? xs)            (append result ys)]
          [(null? ys)            (append result xs)]
          [(< (car xs) (car ys)) (helper (cdr xs) ys       (append result (list (car xs))))]
          [(> (car xs) (car ys)) (helper xs       (cdr ys) (append result (list (car ys))))]
          [else                  (helper (cdr xs) (cdr ys) (append result (list (car xs))))]))
  (helper xs ys '()))

;(set-union '(1 3 5 7)           '(5 7 13))              ; -> '(1 3 5 7 13)
;(set-union '(5 7 13)            '(1 3 5 7))             ; -> '(1 3 5 7 13)
;(set-union '(3 5 7 12 13 14 15) '(1 2 3 4 5 7 8 16 17)) ; -> '(1 2 3 4 5 7 8 12 13 14 15 16 17)


; Задача 9. а) Да се реализира функция (sum-digit-divisors n), която намира сумата на тези от положителните цифри на дадено естествено число, които са му делители.
(define (sum-digit-divisors n)
  (let ([digit (remainder n 10)]
        [next (quotient n 10)])
    (cond [(= 0 n)            0]
          [(divides? digit n) (+ digit (sum-digit-divisors next))] ; divides?, при делител 0 просто връща #f, така че може спокойно да пропуснем проверката дали цифра е положителна
          [else               (sum-digit-divisors next)])))

; б) Да се реализира функция (same-sum a b), която намира броя на двойките числа (m, n), за които a <= m < n <= b и функцията sum-digit-divisors връща един и същ резултат.
(define (same-sum a b)
  (define (helper m n)
    (cond [(= n a)                                           0]
          [(= m n)                                           (helper a (- n 1))]
          [(= (sum-digit-divisors m) (sum-digit-divisors n)) (+ 1 (helper (+ m 1) n))]
          [else                                              (helper (+ m 1) n)]))
  (helper a b))

; все едно въртим два вложени for цикъла:
; for(n = b; n > a; --n)
;   for(m = a; m < n; ++m)

;(same-sum 28 35) ; -> 2 (двойките са (28,32) и (29,34))

; Задача 10. "Метрика" наричаме функция, която приема като параметър списък от числа и връща число като резултат. Да се напише функция best-metric?, която приема като параметри
; списък от метрики ms и списък от списъци от числа xss и проверява дали има метрика в ms, която дава по-големи стойности от всички други метрики от ms над всеки от елементите на xss.
(define (smaller-list xs ys)  ; сравнява списъците поелементно, т.е. проверява дали всеки елемент на xs е по-малък от съответния на ys
  (cond [(or (null? xs) (null? ys)) #t]
        [(<= (car xs) (car ys))     (smaller-list (cdr xs) (cdr ys))]
        [else                       #f]))

;(smaller-list `(1 2 3) `(4 5 6)) ; -> #t
;(smaller-list `(1 3 3) `(1 2 3)) ; -> #f

(define (all-smaller-than xss ys)  ; проверява дали всичките елементи на xss са по-малки списъци от ys
  (andmap (λ (xs) (smaller-list xs ys)) xss))

;(all-smaller-than `()                                `(4 5 6)) ; -> #t
;(all-smaller-than `((1 2 3) (2 3 4))                 `(4 5 6)) ; -> #t
;(all-smaller-than `((1 2 3) (2 3 4) (4 5 6))         `(4 5 6)) ; -> #t
;(all-smaller-than `((1 2 3) (2 3 4) (4 5 6) (5 6 7)) `(4 5 6)) ; -> #f

(define (best-metric? ms xss)
  (let ([applied-metrics (map (λ (m) (map m xss)) ms)])    
    (ormap (λ (xs) (all-smaller-than applied-metrics xs)) applied-metrics)))
    
(define (prod xs) (apply * xs))
(define (sum xs) (apply + xs))
;(best-metric? (list sum prod) `((0 1 2) (3 -4 5) (1337 0)))  ; -> #t
;(best-metric? (list car sum) `((100 -100) (29 1) (42)))      ; -> #f

; Задача 11. "Дълбок списък" ще наричаме списък, който може да съдържа други списъци, а "атом" - елемент на дълбок списък, който не е списък (примерно число или символ).
; "Ниво на влагане" на атом в дълбок списък наричаме броя пъти, който трябва да се приложи операцията car за достигане до атома.
; Да се реализира функция deep-delete, която в даден дълбок списък (в който всеки атом е число) изтрива всички атоми, които са по-малки от нивото им на влагане.
(define (atom? x) (not (pair? x)))

(define (deep-delete xss)
  (define (helper xss depth)
    (define (p? x)
      (and (atom? x) (< x depth))) ; ако има нечислови атоми, ще стане проблем като се опитаме да ги сравним с depth
    (cond [(null? xss)       `()]
          [(list? (car xss)) (cons (helper (car xss) (+ depth 1)) (helper (cdr xss) depth))]
          [(p? (car xss))    (helper (cdr xss) depth)]
          [else              (cons (car xss) (helper (cdr xss) depth))]))
  (helper xss 1))

;(deep-delete `(1 (2 (2 4) 1) 0 (3 (1))))   ; -> (1 (2 (4)) (3 ())))


UPR 8

#lang racket
; от Упражнение 7:
; Задача 11. "Дълбок списък" ще наричаме списък, който може да съдържа други списъци, а "атом" - елемент на дълбок списък, който не е списък (примерно число или символ).
; "Ниво на влагане" на атом в дълбок списък наричаме броя пъти, който трябва да се приложи операцията car за достигане до атома.
; Да се реализира функция deep-delete, която в даден дълбок списък (в който всеки атом е число) изтрива всички атоми, които са по-малки от нивото им на влагане.
(define (atom? x) (not (pair? x)))

(define (deep-delete xss)
  (define (helper xss depth)
    (define (p? x)
      (and (atom? x) (< x depth))) ; ако има нечислови атоми, ще стане проблем като се опитаме да ги сравним с depth
    (cond [(null? xss)       `()]
          [(list? (car xss)) (cons (helper (car xss) (+ depth 1)) (helper (cdr xss) depth))]
          [(p? (car xss))    (helper (cdr xss) depth)]
          [else              (cons (car xss) (helper (cdr xss) depth))]))
  (helper xss 1))

;(deep-delete `(1 (2 (2 4) 1) 0 (3 (1))))   ; -> (1 (2 (4)) (3 ())))


; Упражнение 8:
; Задача 1. Да се дефинира функция (diagonal mat), която получава квадратна числова матрица mat, представена като списък от списъци, и връща списък от елементите на главния диагонал на матрицата.
(define (diagonal mat)
  (if (null? mat)
      `()
      (cons (car (map car mat)) (diagonal (cdr (map cdr mat)))))) ; (map car mat) взима първия стълб, а (cdr (map cdr mat)) взима матрицата без първи стълб и ред
      ;(cons (caar mat) (diagonal (map cdr (cdr mat))))))

(define matrix `((1 2 3 4)
                 (5 6 7 8)
                 (9 10 11 12)
                 (13 14 15 16)))

;(diagonal matrix) ; -> (1 6 11 16)

; Задача 2. Да се дефинира функция от по-висок ред (tabulate f), която връща като резултат функция. Върнатата функция приема като аргументи целите числа a и b и
; връща като резултат списък от точкови двойки от вида '(x . fx), първите елементи на които са поредните точки от интервала [a, b], а вторите – стойностите на f в тези точки. 
(define (tabulate f)
  (λ (a b)
    (map (λ (x) (cons x (f x)))
         (range a (+ b 1)))))

;((tabulate sqr) 1 5) ; -> '((1 . 1) (2 . 4) (3 . 9) (4 . 16) (5 . 25))

; Задача 3. Да се дефинира функцията (latin-square? xss), която проверява дали матрицата xss е латински квадрат (определение на понятието можете да намерите например на https://en.wikipedia.org/wiki/Latin_square). 
; Можете да приемете, че за символи ще използваме числата от 1 до n, където n е големината (броят на редовете/стълбовете) на матрицата. 
(define (transpose xss) (apply map list xss))

(define (square? xss) ; искаме да проверим дали списък от списъци представя квадратна матрица, тоест дали всички редове са с еднаква дължина, и тя е равна на броя редове
  (apply = (cons (length xss) (map length xss)))) ; (map length xss) ще ни даде списък от дължините на редовете, към него с cons добавяме общия броя редове, и с (apply = ...) проверяваме дали всичките са равни
  ;(andmap (λ (x) (= (length x) (length xss))) xss))
;(square? `((1 2) (3 4)))       ; -> #t
;(square? `((1 2) (3 4 5)))     ; -> #f
;(square? `((1 2) (3 4) (5 6))) ; -> #f

(define (latin-square? xss)
  (define (latin-line? xs)
    (let ([n (length xs)])
      (and (= n (length (remove-duplicates xs))) ; няма повторения (ако има, списъкът без тях ще стане по-къс от първоначалния)
           (andmap (λ (x) (and (<= 1 x) (<= x n))) xs)))) ; всичките елементи на реда са между 1 и n (големината на матрицата, която е равна и на дължината на реда в квадратна матрица) 
  (and (square? xss) ; матрицата наистина е квадратна
       (andmap latin-line? xss) ; във всеки ред няма повторения, и елементите са между 1 и n
       (andmap latin-line? (transpose xss)))) ; във всеки ред на транспонираната матрица (т.е. всеки стълб) няма повторения, и елементите са между 1 и n

(define latin '((1 2 3 4)
                (4 3 2 1)
                (2 4 1 3)
                (3 1 4 2)))

;(latin-square? latin) ; -> #t

; Задача 4. Да се дефинира функция (pair-compose fs), която получава списък (f1 f2 f3 ... fn) от едноаргументни числови функции и връща нова едноаргументна числова функция g - 
; такава, че оценката на (g x) е равна на сумата (f1.f2)(x) + (f3.f4)(x) + ... + (fn-1.fn)(x), където "." означава композиция на функции. Ако оригиналният списък с функции има 
; нечетен брой елементи, то последната функция от списъка се композира с функцията идентитет, която получава един аргумент и го връща без промяна.
(define function-list (list sqr
                            (λ (x) (* x x x))
                            (λ (x) (+ x 1))
                            (λ (x) (- x 1))
                            (λ (x) (+ x 2))))

(define (pair-compose fs)
  (define (composed-list xs)
    (cond [(null? xs)       '()]
          [(null? (cdr xs)) (list (compose (car xs) identity))]
          [else             (cons (compose (car xs) (cadr xs)) (composed-list (cddr xs)))]))
  (λ (x) (foldr + 0 (map (λ (f) (f x)) (composed-list fs)))))

;((pair-compose function-list) 4) ; -> 4106 == (4^3)^2 + (4+1-1) + (4+2).id == 4096 + 4 + 6

; Задача 5. Нека l1 = (a1 a2 ... ak) и l2 = (b1 b2 ... bk) са непразни списъци с еднакъв брой числа.
; Да се дефинира предикат (image? l1 l2), който да връща „истина“ точно когато съществува такова число x, че ai = x + bi за всяко i = 1,..., k.
(define (image? l1 l2)
  (let ([x (- (car l1) (car l2))]) ; x = ai - bi
    (equal? l1
            (map (λ (y) (+ y x)) l2)))) ; получаваме списък с елементи x + bi, и проверяваме дали всеки от тях е равен на съответното ai

;(image? '(1 2 3) '(4 5 6)) ; -> #t
;(image? '(1 2 3) '(1 2 2)) ; -> #f
;(image? '(5 6 7) '(1 2 3)) ; -> #t

; Задача 6. Да се дефинира функция (closest-point xys), която приема списък xys от точки в равнината (представени чрез двойки (x.y)) и връща едноаргументна функция,
; чиято стойност в дадена точка p e най-близката до p точка от списъка xys.
(define (closest-point xys)
  (define (distance p1 p2)
    (let ([x1 (car p1)] [y1 (cdr p1)] [x2 (car p2)] [y2 (cdr p2)])
      (sqrt (+ (sqr (- x1 x2)) (sqr (- y1 y2))))))
  
  ; първи вариант - с argmin ((argmin proc lst) връща елемента, който минимизира резултата на proc) 
  ;(λ (p) (cdr (argmin car (map (λ (q) (cons (distance p q) q)) xys)))))
  ; с map конструираме списък от двойки (distance-to-p . (x.y)), с argmin взимаме тази тройка с минимален първи елемент (тоест минимално разстояние), и с cdr взимаме самата точка

  ; втори вариант - с fold
  (λ (p) (foldl (λ (p1 p2) (if (<= (distance p p1) (distance p p2)) p1 p2)) ; тази ламбда функция връща по-близката до p от две точки
                (car xys)
                (cdr xys))))
  ; Това обхождане с fold ще намери най-близката точка. Ако кръстим ламбда функцията f, то ще се получи нещо такова - (f pn ... (f p3 (f p2 p1))...).
  ; (f p2 p1) ще върне по-близката измежду тях, след това тя ще се сравни с p3 и отново ще се вземе по-близката (тоест вече ще имаме най-близката измежду p1, p2 и p3), и т.н., докато накрая не получим
  ; най-близката измежду p1, p2, ..., pn, тоест най-близката точка измежду всичките в списъка.
  ; Тази техника с fold-ване и някаква функция за сравнение може да се ползва и в други случаи, за намиране на минимален/максимален елемент относно някакво условие.

;((closest-point '((1 . 2) (1.2 . 1.3) (3 . 4) (7 . 10))) '(7.1 . 10))  ; -> '(7 . 10)
;((closest-point '((1 . 2) (1.2 . 1.3) (3 . 4) (7 . 10))) '(1 . 2.1))   ; -> '(1 . 2)
;((closest-point '((1 . 2) (1.2 . 1.3) (3 . 4) (7 . 10))) '(1.2 . 1.3)) ; -> '(1.2 . 1.3)

; Задача 7. В лингвистиката т. нар. разстояние на Левенщайн между две думи a и b се дефинира като минималния брой букви, които трябва да бъдат заменени, вмъкнати или изтрити, за да се преобразува a в b.
; https://en.wikipedia.org/wiki/Levenshtein_distance#Definition
; Да се дефинира функция (naive-levenshtein word1 word2), която намира разстоянието на Левенщайн между две дадени думи, представени като списъци от съставящите ги букви.
(define (naive-levenshtein xs ys)
  (cond [(null? xs)                 (length ys)]
        [(null? ys)                 (length xs)]
        [(equal? (car xs) (car ys)) (naive-levenshtein (cdr xs) (cdr ys))]
        [else                       (+ 1 (min (naive-levenshtein (cdr xs) ys)
                                              (naive-levenshtein xs       (cdr ys))
                                              (naive-levenshtein (cdr xs) (cdr ys))))]))

;(naive-levenshtein `(c a t) `(h a t))               ; -> 1
;(naive-levenshtein `(c a t) `(d o g))               ; -> 3
;(naive-levenshtein `(k i t t e n) `(w r i t t e n)) ; -> 2
;(naive-levenshtein `(k i t t e n) `(s i t t i n g)) ; -> 3

; Задача 8. Ако са дадени два списъка от цели числа xs и ys, да се дефинира функция на (contains-multiple-of-all? xs ys), която проверява дали съществува такъв елемент на xs, който е кратен на всички елементи на ys.
(require math/number-theory)

(define (contains-multiple-of-all? xs ys)
  (define (is-multiple x)
    (andmap (λ (y) (divides? y x)) ys)) ; проверява дали всеки елемент на ys дели x (което е еквивалентно на това x да е кратен на всички елементи на ys)
  (ormap is-multiple xs)) ; проверява дали поне един елемент на xs изпълнява is-multiple, т.е. е кратен на всички елементи на ys

;(contains-multiple-of-all? `(3 4 16) `(2 4 8)) ; -> #t (16 е кратно на 2, 4 и 8)
;(contains-multiple-of-all? `(3 4) `(2 4 8))    ; -> #f (3 не е кратно на нито едно от ys, 4 е кратно на 2 и 4, но не на 8)

; Задача 9. Да се дефинира функция (find-max f a b), която по дадена двуаргументна числова функция f и цели числа a и b намира интервалът (i, j), a ≤ i < j ≤ b,
; за който стойността f(i, f(i+1, ... f(j-1, j))) е най-голяма.
(define (subintervals a b) ; връща списък от всички подинтервали на [a,b] (без тези от само един елемент, тъй като искаме i < j)
  (define (helper i j)
    (cond [(= j a) `()]
          [(= i j) (helper a (- j 1))]
          [else    (cons (cons i j) (helper (+ i 1) j))]))
  (helper a b))

(define (find-max f a b)
  (argmax (λ (interval) (foldr f (cdr interval) (range (car interval) (cdr interval))))
          (subintervals a b))) ; конструираме списък с всеки подинтервал на [a,b], и намираме максималния според функция, която смята стойността в условието, ползвайки fold

  ; ако искаме да намерим самата стойност, може така:
  ;(foldr max 0 (map (λ (lst) (foldr f (cdr lst) (range (car lst) (cdr lst))))
  ;                  (subintervals a b)))) ; конструираме списък с всеки подинтервал на [a,b], чрез map за всеки такъв подинтервал [i,j] получаваме съответната стойност на f, и чрез fold взимаме максималната от тях
  
;(find-max - 1 5) ; -> '(3 . 5)
;(find-max + 1 5) ; -> '(1 . 5)
;(find-max * 1 5) ; -> '(1 . 5)
;(find-max / 1 5) ; -> '(3 . 5)


UPR 9 - exam - prep

#lang racket
(require math/number-theory)

; Задача 1. Някои числа имат интересни свойства. Например:
; 89    → 8^1 + 9^2                   = 89 * 1
; 695   → 6^2 + 9^3 + 5^4 = 1390      = 695 * 2
; 46288 → 4^3 + 6^4 + 2^5 + 8^6 + 8^7 = 2360688 = 46288 * 51
; Да се дефинира процедура (dig-pow n p), която приема естествено число n (записано с цифри abcd..., които могат да се повтарят) и намира естествено число k - такова, че
; (a^p + b^(p+1) + c^(p+2) + d^(p+3) + ...) = n*k. Ако число k с посоченото свойство не съществува, да се връща -1.
(define (numToList n)
  (define (numToListReverse n)
    (if (= n 0)
        `()
        (cons (remainder n 10) (numToListReverse (quotient n 10)))))
  (reverse (numToListReverse n)))

(define (dig-pow n p)
  (define (makeSum xs i)
    (if (null? xs)
        0
        (+ (expt (car xs) i) (makeSum (cdr xs) (+ i 1)))))
  (let ([result (makeSum (numToList n) p)])
    (if (divides? n result)
        (quotient result n)
        -1)))
  
;(dig-pow 89 1)    ; -> 1  (8^1 + 9^2 = 89 = 89 * 1)
;(dig-pow 92 1)    ; -> -1 (няма k - такова, че 9^1 + 2^2 = 92 * k)
;(dig-pow 695 2)   ; -> 2  (6^2 + 9^3 + 5^4 = 1390 = 695 * 2)
;(dig-pow 46288 3) ; -> 51 (4^3 + 6^4 + 2^5 + 8^6 + 8^7 = 2360688 = 46288 * 51)


; Задача 2.  Да се дефинира процедура (kth-max-min xs), която приема списък от цели числа и връща процедура с параметър естествено число k - такова, че оценката на израза ((kth-max-min xs) k) e
; k-тото по големина отрицателно число в xs. Ако такова не съществува, да се връща грешката “No such number”.
(define (kth-max-min xs)
  (define (kth-element xs k)
    (cond [(null? xs) (error "No such number.")]
          [(= k 1) (car xs)]
          [else    (kth-element (cdr xs) (- k 1))]))
  (let ([negatives-list (sort (remove-duplicates (filter negative? xs)) >)])
    (λ (k) (kth-element negatives-list k))))
    ; може и да позлваме list-ref вместо да си дефинираме наша функция за взимане на k-ти
    #|(λ (k) (if (> k (length negatives-list))
               (error "No such number")
               (list-ref negatives-list (- k 1))))))|#

;((kth-max-min '(1 2 3 4 -5 6 7 -2 -1 0)) 2)  ; -> -2
;((kth-max-min '(-1 0 -1 0 -2 3 1 -1)) 3)     ; No such number
;((kth-max-min '(-4 -3 -5 -8 -7)) 2)          ; -> -4


; Задача 3. Да се дефинира процедура (shuffle xs), получава списък от 2*n елемента във вида ‘(x1 x2 .. xn y1 y2 .. yn) и връща списък във вида ‘(x1 y1 x2  y2 .. xn  yn).
; първи вариант
(define (shuffle xs)
  (define (helper xs ys)
    (if (null? xs)
        `()
        (append (list (car xs) (car ys)) (helper (cdr xs) (cdr ys)))))
        ;(cons (car xs) (cons (car ys) (helper (cdr xs) (cdr ys))))))
  (let ([n (/ (length xs) 2)])
    (helper (take xs n) (drop xs n))))

;(shuffle '(2 5 1 3 4 7))     ; -> '(2 3 5 4 1 7)
;(shuffle '(1 2 3 4 4 3 2 1)) ; -> '(1 4 2 3 3 2 4 1)
;(shuffle '(1 1 2 2))         ; -> '(1 2 1 2)

; втори вариант с ползване на zipWith
(define (zipWith f xs ys)
  (cond [(null? xs) `()]
        [(null? ys) `()]
        [else (cons (f (car xs) (car ys)) (zipWith f (cdr xs) (cdr ys)))]))

(define (shuffleZip xs)
  (let ([n (/ (length xs) 2)])
    (apply append (zipWith list (take xs n) (drop xs n)))))
    ;(apply append (map list (take xs n) (drop xs n))))) ; може и вместо zipWith да ползваме директно map, тъй като в Racket той може да приеме функция на k аргумента, и да я приложи над k списъка


; Задача 4. Да се дефинира предикат (triangular? mat), който получава квадратна числова матрица, представена като списък от списъци, и проверява дали тя е горно триъгълна,
; т.е. дали всичките елементи под главния ѝ диагонал са нули.
(define (triangular? mat)
  (define (helper mat i)
    (cond [(empty? mat)                         #t]
          [(andmap zero? (take (car mat) i)) (helper (cdr mat) (+ i 1))]
          [else                                 #f]))
  (helper (cdr mat) 1))

(triangular? '((1 2 3)
               (0 5 6)
               (0 0 9))) ; -> #t
(triangular? '((0 2 3)
               (0 0 6)
               (1 0 0))) ; -> #f
(triangular? '((1 2 3)
               (1 5 6)
               (0 0 9))) ; -> #f
(triangular? '((1 2 3 4)
               (0 5 6 7)
               (0 0 8 9)
               (0 0 0 9))) ; -> #t
(triangular? '((0 0 1 1)
               (0 1 1 1)
               (0 0 1 1)
               (0 0 0 1))) ; -> #t


-- HW 1
#lang racket

; Задача 1. Да се дефинира предикат (automorphic? n), който приема естествено число n и проверява дали n^2 завършва с цифрите на n.
(define (finishes-with a b)
  (cond [(or (= b 0) (= a 0))                  #t]
        [(= (remainder a 10) (remainder b 10)) (finishes-with (quotient a 10) (quotient b 10))]
        [else                                  #f]))

(define (automorphic? n)
  (finishes-with n (sqr n)))

(automorphic? 5) ; -> #t
(automorphic? 25) ; -> #t
(automorphic? 36) ; -> #f
(automorphic? 890625) ; -> #t


(require math/number-theory)
; Задача 2. Ще наричаме едно число кубично просто число, ако е просто и може да бъде представено като разлика на кубовете на две последователни естествени числа. 61 е такова число, защото е просто и 61 = 5^3 - 4^3.
; Дефинирайте процедура (nth-cuban n), която чрез линейно итеративен процес връща n-тото кубично просто число.

; неефективно решение
(define (cuban? n)
  (define (special-diff curr)
    (let ([next (+ curr 1)])
      (- (* next next next) (* curr curr curr))))
  
  (define (check-diff i)
    (cond [(> i n)                #f]
          [(= n (special-diff i)) #t]
          [else                   (check-diff (+ i 1))]))
  
  (and (prime? n) (check-diff 1)))

(define (nth-cuban-ineffective n)
  (define (helper i curr last-found)
    (cond [(> i n)       last-found]
          [(cuban? curr) (helper (+ i 1) (+ curr 1) curr)]
          [else          (helper i       (+ curr 1) last-found)]))
  (helper 1 1 1))


(define (nth-cuban n)
  (define (helper curr i last-found) ; чрез curr просто итерираме през естествените числа, в i отчитаме до кое кубично просто число сме стигнали, а в last-found пазим последното намерено кубично просто
    (let* ([next (+ curr 1)]
           [candidate (- (* next next next) (* curr curr curr))])
      (cond [(> i n)            last-found]
            [(prime? candidate) (helper (+ curr 1) (+ i 1) candidate)]
            [else               (helper (+ curr 1) i       last-found)])))
  (helper 1 1 1))

(nth-cuban 1)    ; -> 7      (8 - 1)
(nth-cuban 2)    ; -> 19     (27 - 8)
(nth-cuban 3)    ; -> 37     (64 - 27)
(nth-cuban 4)    ; -> 61     (125 - 64)
(nth-cuban 5)    ; -> 127    (343 - 216)
(nth-cuban 50)   ; -> 55897  (137^3 - 136^3 = 2571353 - 2515456)
(nth-cuban 100)  ; -> 283669 (308^3 - 307^3 = 29218112 - 28934443

(time (nth-cuban 50)) ; -> cpu time: 157 real time: 156 gc time: 48
(time (nth-cuban-ineffective 50)) ; -> cpu time: 6344 real time: 6402 gc time: 111

-- HW 2

#lang racket

; Задача 1. Да се дефинира функцията (cartesian-product xs ys), която връща като резултат списък от двойки, представящ декартовото произведение на множествата xs и ys, представени чрез списъци.
(define (cartesian-product xs ys)
  (define (helper left right)
    (cond [(empty? left) '()]
          [(empty? right) (helper (cdr left) ys)]
          [else (cons (cons (car left) (car right)) (helper left (cdr right)))]))
  (helper xs ys))

(cartesian-product '(1 2 3 4 5) '(6 7 8)) ; -> '((1 . 6) (1 . 7) (1 . 8) (2 . 6) (2 . 7) (2 . 8) (3 . 6) (3 . 7) (3 . 8) (4 . 6) (4 . 7) (4 . 8) (5 . 6) (5 . 7) (5 . 8))
(cartesian-product '(1 2) '(3 4)) ; -> '((1 . 3) (1 . 4) (2 . 3) (2 . 4))

; втори вариант - с append и map
(define (cartesian-product-map xs ys)
  (apply append
         (map (λ (x) (map (λ (y) (cons x y)) ys))
              xs)))
; За всеки елемент xi от xs конструираме списък от двойки ((xi,y1) (xi,y2) ... (xi,yn)), където y1, y2, ..., yn са елементите на ys.
; Резултатът е списък от списъци (((x1,y1) ... (x1,yn)) ((x2,y1) ... (x2, yn)) ... ((xk,y1) ... (xk,yn))) , поради което се налага apply append, за да получим списък със самите двойки

; Задача 2. Според основната теорема на аритметиката, всяко естествено число, което е по-голямо от 2, може да се представи като произведение на прости числа.
; Да се дефинира функция (factorize n), която приема естествено число n, по-голямо от 1, и връща сортиран списък от елементите на това представяне.
(require math/number-theory)

(define (factorize n)
  (define (helper i)
    (cond [(= n 1)       `()]
          [(divides? i n) (cons i (factorize (quotient n i)))]
          [else           (helper (+ i 1))]))
  (helper 2))

(factorize 2)          ; -> '(2)
(factorize 3)          ; -> '(3)
(factorize 6)          ; -> '(2 3)
(factorize 13)         ; -> '(13)
(factorize 123)        ; -> '(3 41)
(factorize 152)        ; -> '(2 2 2 19)
(factorize 128)        ; -> '(2 2 2 2 2 2 2)
(factorize 1134472500) ; -> '(2 2 3 3 3 5 5 5 5 7 7 7 7 7)




